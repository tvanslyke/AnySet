<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>any-set-docs: te::AnySet&lt; HashFn, KeyEqual, Allocator &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">any-set-docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>te</b></li><li class="navelem"><a class="el" href="structte_1_1AnySet.html">AnySet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structte_1_1AnySet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">te::AnySet&lt; HashFn, KeyEqual, Allocator &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__AnySet-Module.html">AnySet-Module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt;<br />
struct te::AnySet&lt; HashFn, KeyEqual, Allocator &gt;</h3>

<p><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> is an associative container that contains a set of unique objects of any constructible type. Search, insertion, and removal have average constant-time complexity. Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into. </p>
<p>Container elements may not be modified (even by non const iterators) since modification could change an element's hash and corrupt the container.</p>
<p><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> meets the requirements of <a href="http://en.cppreference.com/w/cpp/concept/Container">Container</a>, <a href="http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer">AllocatorAwareContainer</a>, and <a href="http://en.cppreference.com/w/cpp/concept/UnorderedAssociativeContainer">UnorderedAssociativeContainer</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to provide certain functionality functionality and mimic the behavior of similar standard containers (such as std::unordered_set&lt;&gt;), <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> must sacrifice some static type safety in the name of usability. For example, <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances are always copy constructible. However, if an attempt is made to copy construct or assign (or similar) from an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance that contains instances of non-copy-constructible types, an exception is thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HashFn</td><td>- The type of the function object to use when computing the hash codes of elements. </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>- The type of the function object to use when comparing elements for equality. </td></tr>
    <tr><td class="paramname">Allocator</td><td>- The type of the allocator to use when allocating the internal bucket table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The STL's allocator model is too rigid for <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> to sanely support customized allocation of its internal nodes. Thus its internal elements/nodes are simply allocated using std::make_unique() (effectively using the keyword 'new'). Allocator support is only provided for the internal bucket table.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnyValue.html">AnyValue</a> - User-visible <code><a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73" title="AnyValue. ">value_type</a></code> for <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances. </dd>
<dd>
<a class="el" href="structte_1_1AnyHash.html" title="Generic hash function object. ">AnyHash</a> - The default value of HashFn. It <a class="el" href="structte_1_1AnyValue.html#a0b97a869d111b68fabac62d4c10418c7" title="Check if any_v contains an object of type T. ">is</a> intended to be sufficiently extensible such that users should not need to roll their own HashFn types. </dd></dl>
</div>
<p><code>#include &lt;<a class="el" href="AnySet_8h_source.html">AnySet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator type returned from const operations on <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances.  <a href="structte_1_1AnySet_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator type returned from non-const operations on <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances.  <a href="structte_1_1AnySet_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2a15e80792ba9325429a42bbe2325e73"><td class="memItemLeft" align="right" valign="top"><a id="a2a15e80792ba9325429a42bbe2325e73"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> = <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, KeyEqual &gt;</td></tr>
<tr class="memdesc:a2a15e80792ba9325429a42bbe2325e73"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structte_1_1AnyValue.html">AnyValue</a>. <br /></td></tr>
<tr class="separator:a2a15e80792ba9325429a42bbe2325e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dbae91d0a3f389bb1862d4d9d2a7d9"><td class="memItemLeft" align="right" valign="top"><a id="a39dbae91d0a3f389bb1862d4d9d2a7d9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> = typename vector_type::size_type</td></tr>
<tr class="memdesc:a39dbae91d0a3f389bb1862d4d9d2a7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type. <br /></td></tr>
<tr class="separator:a39dbae91d0a3f389bb1862d4d9d2a7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6c0e28fee9b4a3f8ea81e2bd55e28b"><td class="memItemLeft" align="right" valign="top"><a id="a9c6c0e28fee9b4a3f8ea81e2bd55e28b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a9c6c0e28fee9b4a3f8ea81e2bd55e28b">difference_type</a> = typename vector_type::difference_type</td></tr>
<tr class="memdesc:a9c6c0e28fee9b4a3f8ea81e2bd55e28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type. <br /></td></tr>
<tr class="separator:a9c6c0e28fee9b4a3f8ea81e2bd55e28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad77e4efb4d9e761042f816af59a4a4"><td class="memItemLeft" align="right" valign="top"><a id="a8ad77e4efb4d9e761042f816af59a4a4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a8ad77e4efb4d9e761042f816af59a4a4">key_equal</a> = KeyEqual</td></tr>
<tr class="memdesc:a8ad77e4efb4d9e761042f816af59a4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality comparator type. <br /></td></tr>
<tr class="separator:a8ad77e4efb4d9e761042f816af59a4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d67e0b2dc842b7f6b858b974b694e4f"><td class="memItemLeft" align="right" valign="top"><a id="a8d67e0b2dc842b7f6b858b974b694e4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a8d67e0b2dc842b7f6b858b974b694e4f">hasher</a> = HashFn</td></tr>
<tr class="memdesc:a8d67e0b2dc842b7f6b858b974b694e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function type. <br /></td></tr>
<tr class="separator:a8d67e0b2dc842b7f6b858b974b694e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034124e5f924602e12198f57f8dc18ae"><td class="memItemLeft" align="right" valign="top"><a id="a034124e5f924602e12198f57f8dc18ae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a034124e5f924602e12198f57f8dc18ae">allocator_type</a> = Allocator</td></tr>
<tr class="memdesc:a034124e5f924602e12198f57f8dc18ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type. <br /></td></tr>
<tr class="separator:a034124e5f924602e12198f57f8dc18ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee089bf8502c8d062ebb0b493111fc1"><td class="memItemLeft" align="right" valign="top"><a id="a4ee089bf8502c8d062ebb0b493111fc1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a4ee089bf8502c8d062ebb0b493111fc1">key_type</a> = <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a></td></tr>
<tr class="memdesc:a4ee089bf8502c8d062ebb0b493111fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structte_1_1AnyValue.html">AnyValue</a>. Here for consistency with std::unordered_set. <br /></td></tr>
<tr class="separator:a4ee089bf8502c8d062ebb0b493111fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebc7157c6f105886de8e40fc0c3d9ad"><td class="memItemLeft" align="right" valign="top"><a id="a0ebc7157c6f105886de8e40fc0c3d9ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a0ebc7157c6f105886de8e40fc0c3d9ad">reference</a> = <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> &amp;</td></tr>
<tr class="memdesc:a0ebc7157c6f105886de8e40fc0c3d9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>. <br /></td></tr>
<tr class="separator:a0ebc7157c6f105886de8e40fc0c3d9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce3c18f84fe9f996434290602994109"><td class="memItemLeft" align="right" valign="top"><a id="abce3c18f84fe9f996434290602994109"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#abce3c18f84fe9f996434290602994109">const_reference</a> = const <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> &amp;</td></tr>
<tr class="memdesc:abce3c18f84fe9f996434290602994109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>. <br /></td></tr>
<tr class="separator:abce3c18f84fe9f996434290602994109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572260b03bc8d5d23eb71f0c0e6193d0"><td class="memItemLeft" align="right" valign="top"><a id="a572260b03bc8d5d23eb71f0c0e6193d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a572260b03bc8d5d23eb71f0c0e6193d0">pointer</a> = <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> *</td></tr>
<tr class="memdesc:a572260b03bc8d5d23eb71f0c0e6193d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>. <br /></td></tr>
<tr class="separator:a572260b03bc8d5d23eb71f0c0e6193d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70003fbdad1535a8ee15fba0b13d670b"><td class="memItemLeft" align="right" valign="top"><a id="a70003fbdad1535a8ee15fba0b13d670b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a70003fbdad1535a8ee15fba0b13d670b">const_pointer</a> = const <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> *</td></tr>
<tr class="memdesc:a70003fbdad1535a8ee15fba0b13d670b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>. <br /></td></tr>
<tr class="separator:a70003fbdad1535a8ee15fba0b13d670b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2cffe66078db7aa7916cdac9badfc6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> = std::unique_ptr&lt; <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> &gt;</td></tr>
<tr class="separator:a4c2cffe66078db7aa7916cdac9badfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f920cc2c53d8f0dcdfe67f262277f2"><td class="memItemLeft" align="right" valign="top"><a id="a18f920cc2c53d8f0dcdfe67f262277f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">local_iterator</a> = BucketIterator&lt; false &gt;</td></tr>
<tr class="memdesc:a18f920cc2c53d8f0dcdfe67f262277f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type suitable for traversal through an individual bucket. <br /></td></tr>
<tr class="separator:a18f920cc2c53d8f0dcdfe67f262277f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f28f327d868e6c6cbccdd6eedad636e"><td class="memItemLeft" align="right" valign="top"><a id="a8f28f327d868e6c6cbccdd6eedad636e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> = BucketIterator&lt; true &gt;</td></tr>
<tr class="memdesc:a8f28f327d868e6c6cbccdd6eedad636e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type suitable for traversal through an individual bucket. <br /></td></tr>
<tr class="separator:a8f28f327d868e6c6cbccdd6eedad636e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5109fe416285d478b1f1ccd30d9585e"><td class="memItemLeft" align="right" valign="top"><a id="aa5109fe416285d478b1f1ccd30d9585e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_assert_invariants</b> (bool check_load_factor=false) const</td></tr>
<tr class="separator:aa5109fe416285d478b1f1ccd30d9585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a8889bd44aeb88168a6a7ffb277b5c0cd"><td class="memItemLeft" align="right" valign="top"><a id="a8889bd44aeb88168a6a7ffb277b5c0cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a8889bd44aeb88168a6a7ffb277b5c0cd">AnySet</a> ()</td></tr>
<tr class="memdesc:a8889bd44aeb88168a6a7ffb277b5c0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty set with 1 bucket. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. <br /></td></tr>
<tr class="separator:a8889bd44aeb88168a6a7ffb277b5c0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966efeede2c85ea0e11b7af0366119ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a966efeede2c85ea0e11b7af0366119ec">AnySet</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>, const HashFn &amp;hash=HashFn(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a966efeede2c85ea0e11b7af0366119ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0.  <a href="#a966efeede2c85ea0e11b7af0366119ec">More...</a><br /></td></tr>
<tr class="separator:a966efeede2c85ea0e11b7af0366119ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a64b737fb06974c4658dff89717f252"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a6a64b737fb06974c4658dff89717f252">AnySet</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a6a64b737fb06974c4658dff89717f252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0.  <a href="#a6a64b737fb06974c4658dff89717f252">More...</a><br /></td></tr>
<tr class="separator:a6a64b737fb06974c4658dff89717f252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158e154a3d03b13e4a035342bfe70569"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a158e154a3d03b13e4a035342bfe70569">AnySet</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>, const HashFn &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a158e154a3d03b13e4a035342bfe70569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0.  <a href="#a158e154a3d03b13e4a035342bfe70569">More...</a><br /></td></tr>
<tr class="separator:a158e154a3d03b13e4a035342bfe70569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e3a32bb198fb9a4de9a8917c1123f2"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ab4e3a32bb198fb9a4de9a8917c1123f2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ab4e3a32bb198fb9a4de9a8917c1123f2">AnySet</a> (InputIt first, InputIt last, <a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>=0, const HashFn &amp;hash=HashFn(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:ab4e3a32bb198fb9a4de9a8917c1123f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the range [first, last). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the range compare equivalent, only the first encountered is inserted.  <a href="#ab4e3a32bb198fb9a4de9a8917c1123f2">More...</a><br /></td></tr>
<tr class="separator:ab4e3a32bb198fb9a4de9a8917c1123f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e098e80fdf2b2192319ff76d601a1c3"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a8e098e80fdf2b2192319ff76d601a1c3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a8e098e80fdf2b2192319ff76d601a1c3">AnySet</a> (InputIt first, InputIt last, <a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a8e098e80fdf2b2192319ff76d601a1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the range [first, last). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the range compare equivalent, only the first encountered is inserted.  <a href="#a8e098e80fdf2b2192319ff76d601a1c3">More...</a><br /></td></tr>
<tr class="separator:a8e098e80fdf2b2192319ff76d601a1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1df747c2198efd5efe5ba16bfb314d"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a9b1df747c2198efd5efe5ba16bfb314d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a9b1df747c2198efd5efe5ba16bfb314d">AnySet</a> (InputIt first, InputIt last, <a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>, const HashFn &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a9b1df747c2198efd5efe5ba16bfb314d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the range [first, last). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the range compare equivalent, only the first encountered is inserted.  <a href="#a9b1df747c2198efd5efe5ba16bfb314d">More...</a><br /></td></tr>
<tr class="separator:a9b1df747c2198efd5efe5ba16bfb314d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc47a853ec464d1e32b53b9747156747"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#adc47a853ec464d1e32b53b9747156747">AnySet</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:adc47a853ec464d1e32b53b9747156747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from other. Constructs the set with the copy of the contents of other. Copies the load factor, the predicate, and the hash function as well.  <a href="#adc47a853ec464d1e32b53b9747156747">More...</a><br /></td></tr>
<tr class="separator:adc47a853ec464d1e32b53b9747156747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aa2884c8d394bf7eeb6459224307c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ae6aa2884c8d394bf7eeb6459224307c6">AnySet</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;other)</td></tr>
<tr class="memdesc:ae6aa2884c8d394bf7eeb6459224307c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from other. Constructs the set with the copy of the contents of other. Copies the load factor, the predicate, and the hash function as well.  <a href="#ae6aa2884c8d394bf7eeb6459224307c6">More...</a><br /></td></tr>
<tr class="separator:ae6aa2884c8d394bf7eeb6459224307c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226874c61eb1eb38eee1f2ce0ab990a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a226874c61eb1eb38eee1f2ce0ab990a4">AnySet</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a226874c61eb1eb38eee1f2ce0ab990a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from other. Constructs the set with the copy of the contents of other. Copies the load factor, the predicate, and the hash function as well.  <a href="#a226874c61eb1eb38eee1f2ce0ab990a4">More...</a><br /></td></tr>
<tr class="separator:a226874c61eb1eb38eee1f2ce0ab990a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65383e7f9deaaa338bf4a016a7106f72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a65383e7f9deaaa338bf4a016a7106f72">AnySet</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a65383e7f9deaaa338bf4a016a7106f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from other. Constructs the set with the copy of the contents of other. Copies the load factor, the predicate, and the hash function as well.  <a href="#a65383e7f9deaaa338bf4a016a7106f72">More...</a><br /></td></tr>
<tr class="separator:a65383e7f9deaaa338bf4a016a7106f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584bb61c6139493b3ca4859d261d09e6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a584bb61c6139493b3ca4859d261d09e6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a584bb61c6139493b3ca4859d261d09e6">AnySet</a> (std::initializer_list&lt; T &gt; ilist, <a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>=0, const HashFn &amp;hash=HashFn(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a584bb61c6139493b3ca4859d261d09e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the initializer list ilist. Same as <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>(init.begin(), init.end()). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the list compare equivalent, only the first encountered is inserted.  <a href="#a584bb61c6139493b3ca4859d261d09e6">More...</a><br /></td></tr>
<tr class="separator:a584bb61c6139493b3ca4859d261d09e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1bc5833fb79e44ef1dcdd5e3c88bcf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abd1bc5833fb79e44ef1dcdd5e3c88bcf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#abd1bc5833fb79e44ef1dcdd5e3c88bcf">AnySet</a> (std::initializer_list&lt; T &gt; ilist, <a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:abd1bc5833fb79e44ef1dcdd5e3c88bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the initializer list ilist. Same as <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>(init.begin(), init.end()). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the list compare equivalent, only the first encountered is inserted.  <a href="#abd1bc5833fb79e44ef1dcdd5e3c88bcf">More...</a><br /></td></tr>
<tr class="separator:abd1bc5833fb79e44ef1dcdd5e3c88bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa168fffe9f11ad2ebde217740baa1cbf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa168fffe9f11ad2ebde217740baa1cbf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#aa168fffe9f11ad2ebde217740baa1cbf">AnySet</a> (std::initializer_list&lt; T &gt; ilist, <a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>, const HashFn &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:aa168fffe9f11ad2ebde217740baa1cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the initializer list ilist. Same as <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>(init.begin(), init.end()). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the list compare equivalent, only the first encountered is inserted.  <a href="#aa168fffe9f11ad2ebde217740baa1cbf">More...</a><br /></td></tr>
<tr class="separator:aa168fffe9f11ad2ebde217740baa1cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ab2e1618e11f308fee56d1e840b603"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a15ab2e1618e11f308fee56d1e840b603"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a15ab2e1618e11f308fee56d1e840b603">AnySet</a> (std::tuple&lt; T ... &gt; &amp;&amp;tup, <a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>=2 *(sizeof...(T)), const HashFn &amp;hash=HashFn(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a15ab2e1618e11f308fee56d1e840b603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the tuple tup. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the tuple have the same type and compare equivalent,only the first encountered is inserted.  <a href="#a15ab2e1618e11f308fee56d1e840b603">More...</a><br /></td></tr>
<tr class="separator:a15ab2e1618e11f308fee56d1e840b603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0366d2d6867776b8ebfacaa167b4a5b0"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a0366d2d6867776b8ebfacaa167b4a5b0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a0366d2d6867776b8ebfacaa167b4a5b0">AnySet</a> (std::tuple&lt; T ... &gt; &amp;&amp;tup, <a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a0366d2d6867776b8ebfacaa167b4a5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the tuple tup. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the tuple have the same type and compare equivalent,only the first encountered is inserted.  <a href="#a0366d2d6867776b8ebfacaa167b4a5b0">More...</a><br /></td></tr>
<tr class="separator:a0366d2d6867776b8ebfacaa167b4a5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd6af9b081ad61a07e81090334614e2"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:aadd6af9b081ad61a07e81090334614e2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#aadd6af9b081ad61a07e81090334614e2">AnySet</a> (std::tuple&lt; T ... &gt; &amp;&amp;tup, <a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>, const HashFn &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:aadd6af9b081ad61a07e81090334614e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the tuple tup. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the tuple have the same type and compare equivalent,only the first encountered is inserted.  <a href="#aadd6af9b081ad61a07e81090334614e2">More...</a><br /></td></tr>
<tr class="separator:aadd6af9b081ad61a07e81090334614e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr class="memitem:aadc20b7c67d5c635b2c54b9b2f00ae40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#aadc20b7c67d5c635b2c54b9b2f00ae40">operator=</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;other)</td></tr>
<tr class="memdesc:aadc20b7c67d5c635b2c54b9b2f00ae40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigns the contents of this <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the contents of other. Copies the load factor, the predicate, the hash function, and allocator as well.  <a href="#aadc20b7c67d5c635b2c54b9b2f00ae40">More...</a><br /></td></tr>
<tr class="separator:aadc20b7c67d5c635b2c54b9b2f00ae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3ff8ce9e70828b4240a67129eb5e83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#acf3ff8ce9e70828b4240a67129eb5e83">operator=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;&amp;other) noexcept(std::is_nothrow_move_assignable_v&lt; vector_type &gt;)</td></tr>
<tr class="memdesc:acf3ff8ce9e70828b4240a67129eb5e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigns the contents of this <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the contents of other. Moves the load factor, the predicate, the hash function, and allocator as well.  <a href="#acf3ff8ce9e70828b4240a67129eb5e83">More...</a><br /></td></tr>
<tr class="separator:acf3ff8ce9e70828b4240a67129eb5e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada8bfe6c1bbc1e2300d8eeaf6621c1b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aada8bfe6c1bbc1e2300d8eeaf6621c1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#aada8bfe6c1bbc1e2300d8eeaf6621c1b">operator=</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:aada8bfe6c1bbc1e2300d8eeaf6621c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of this <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance with the contents of ilist.  <a href="#aada8bfe6c1bbc1e2300d8eeaf6621c1b">More...</a><br /></td></tr>
<tr class="separator:aada8bfe6c1bbc1e2300d8eeaf6621c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a4573f5334af88c606b3f73da6c6c0916"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a4573f5334af88c606b3f73da6c6c0916">cbegin</a> () const</td></tr>
<tr class="memdesc:a4573f5334af88c606b3f73da6c6c0916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> to the first element in the set.  <a href="#a4573f5334af88c606b3f73da6c6c0916">More...</a><br /></td></tr>
<tr class="separator:a4573f5334af88c606b3f73da6c6c0916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d77aa672a65bf4adf8f7811ea8180b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a88d77aa672a65bf4adf8f7811ea8180b">begin</a> () const</td></tr>
<tr class="memdesc:a88d77aa672a65bf4adf8f7811ea8180b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> to the first element in the set.  <a href="#a88d77aa672a65bf4adf8f7811ea8180b">More...</a><br /></td></tr>
<tr class="separator:a88d77aa672a65bf4adf8f7811ea8180b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48961e895f29eb637b40166f2ad94d00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00">begin</a> ()</td></tr>
<tr class="memdesc:a48961e895f29eb637b40166f2ad94d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a iterator to the first element in the set.  <a href="#a48961e895f29eb637b40166f2ad94d00">More...</a><br /></td></tr>
<tr class="separator:a48961e895f29eb637b40166f2ad94d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ea6c78bad173c6f63152992efa364a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a60ea6c78bad173c6f63152992efa364a">cend</a> () const</td></tr>
<tr class="memdesc:a60ea6c78bad173c6f63152992efa364a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a past-the-end <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> for this set.  <a href="#a60ea6c78bad173c6f63152992efa364a">More...</a><br /></td></tr>
<tr class="separator:a60ea6c78bad173c6f63152992efa364a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4e76a019d6e5e20c66ef9c32d6b3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a6f4e76a019d6e5e20c66ef9c32d6b3ee">end</a> () const</td></tr>
<tr class="memdesc:a6f4e76a019d6e5e20c66ef9c32d6b3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a past-the-end <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> for this set.  <a href="#a6f4e76a019d6e5e20c66ef9c32d6b3ee">More...</a><br /></td></tr>
<tr class="separator:a6f4e76a019d6e5e20c66ef9c32d6b3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730117cbdfa732d5739dcaedd99eaf64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64">end</a> ()</td></tr>
<tr class="memdesc:a730117cbdfa732d5739dcaedd99eaf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a past-the-end iterator for this set.  <a href="#a730117cbdfa732d5739dcaedd99eaf64">More...</a><br /></td></tr>
<tr class="separator:a730117cbdfa732d5739dcaedd99eaf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr class="memitem:a393e3a7a552f2d5cda17ee0bfa0a251e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a393e3a7a552f2d5cda17ee0bfa0a251e">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a393e3a7a552f2d5cda17ee0bfa0a251e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set has no elements, i.e. whether <a class="el" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00" title="Get a iterator to the first element in the set. ">begin()</a> == <a class="el" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64" title="Get a past-the-end iterator for this set. ">end()</a>.  <a href="#a393e3a7a552f2d5cda17ee0bfa0a251e">More...</a><br /></td></tr>
<tr class="separator:a393e3a7a552f2d5cda17ee0bfa0a251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82c525d87429e9586026c549d5fca34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#aa82c525d87429e9586026c549d5fca34">size</a> () const noexcept</td></tr>
<tr class="memdesc:aa82c525d87429e9586026c549d5fca34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements in the set, i.e. std::distance(<a class="el" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00" title="Get a iterator to the first element in the set. ">begin()</a>, <a class="el" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64" title="Get a past-the-end iterator for this set. ">end()</a>).  <a href="#aa82c525d87429e9586026c549d5fca34">More...</a><br /></td></tr>
<tr class="separator:aa82c525d87429e9586026c549d5fca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca85fcaf35763f2339e77bbf93f505e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a8ca85fcaf35763f2339e77bbf93f505e">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a8ca85fcaf35763f2339e77bbf93f505e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00" title="Get a iterator to the first element in the set. ">begin()</a>, <a class="el" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64" title="Get a past-the-end iterator for this set. ">end()</a>) for the largest container.  <a href="#a8ca85fcaf35763f2339e77bbf93f505e">More...</a><br /></td></tr>
<tr class="separator:a8ca85fcaf35763f2339e77bbf93f505e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr class="memitem:a3cf95080869e749c8e06cf7f4f9130a4"><td class="memItemLeft" align="right" valign="top"><a id="a3cf95080869e749c8e06cf7f4f9130a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a3cf95080869e749c8e06cf7f4f9130a4">clear</a> () noexcept</td></tr>
<tr class="memdesc:a3cf95080869e749c8e06cf7f4f9130a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the container. Invalidates any references, pointers, or iterators referring to contained elements. <br /></td></tr>
<tr class="separator:a3cf95080869e749c8e06cf7f4f9130a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1714daaedbc435c19d0bd94320a3d15"><td class="memTemplParams" colspan="2">template&lt;class T , class ... Args&gt; </td></tr>
<tr class="memitem:ae1714daaedbc435c19d0bd94320a3d15"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ae1714daaedbc435c19d0bd94320a3d15">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae1714daaedbc435c19d0bd94320a3d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the same type and value in the container.  <a href="#ae1714daaedbc435c19d0bd94320a3d15">More...</a><br /></td></tr>
<tr class="separator:ae1714daaedbc435c19d0bd94320a3d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e4dcb2691ff7bca954aa1b6e8a7f3d"><td class="memTemplParams" colspan="2">template&lt;class T , class ... Args&gt; </td></tr>
<tr class="memitem:ae5e4dcb2691ff7bca954aa1b6e8a7f3d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ae5e4dcb2691ff7bca954aa1b6e8a7f3d">emplace_hint</a> ([[maybe_unused]] <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> hint, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae5e4dcb2691ff7bca954aa1b6e8a7f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the same type and value in the container, using an iterator hint as a suggestion for where the new element should be placed.  <a href="#ae5e4dcb2691ff7bca954aa1b6e8a7f3d">More...</a><br /></td></tr>
<tr class="separator:ae5e4dcb2691ff7bca954aa1b6e8a7f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e113b687669fcc70d2aab15581eba4b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9e113b687669fcc70d2aab15581eba4b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a9e113b687669fcc70d2aab15581eba4b">insert</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a9e113b687669fcc70d2aab15581eba4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into the set, if the set doesn't already contain an element with an equivalent value and type.  <a href="#a9e113b687669fcc70d2aab15581eba4b">More...</a><br /></td></tr>
<tr class="separator:a9e113b687669fcc70d2aab15581eba4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5963685181390d0b2730e401a38998c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af5963685181390d0b2730e401a38998c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#af5963685181390d0b2730e401a38998c">insert</a> ([[maybe_unused]] <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> hint, T &amp;&amp;value)</td></tr>
<tr class="memdesc:af5963685181390d0b2730e401a38998c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into the set, if the set doesn't already contain an element with an equivalent value and type.  <a href="#af5963685181390d0b2730e401a38998c">More...</a><br /></td></tr>
<tr class="separator:af5963685181390d0b2730e401a38998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6777a564b3a11d8e0eb3936f1f98376"><td class="memTemplParams" colspan="2">template&lt;class It , class  = std::enable_if_t&lt;			std::is_copy_constructible_v&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;			or std::is_rvalue_reference_v&lt;decltype(*std::declval&lt;It&gt;())&gt;		&gt;&gt; </td></tr>
<tr class="memitem:ab6777a564b3a11d8e0eb3936f1f98376"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ab6777a564b3a11d8e0eb3936f1f98376">insert</a> (It first, It last)</td></tr>
<tr class="memdesc:ab6777a564b3a11d8e0eb3936f1f98376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from the range [first, last) that do not already exist in the set. If multiple elements in the range have values that compare equivalent, and there is no such element already in the set, only the first encountered is inserted.  <a href="#ab6777a564b3a11d8e0eb3936f1f98376">More...</a><br /></td></tr>
<tr class="separator:ab6777a564b3a11d8e0eb3936f1f98376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7d6344803cdd2c500fc69195caafa5"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class ... V&gt; </td></tr>
<tr class="memitem:aaf7d6344803cdd2c500fc69195caafa5"><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; 2ull+sizeof...(V)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#aaf7d6344803cdd2c500fc69195caafa5">insert</a> (T &amp;&amp;first, U &amp;&amp;second, V &amp;&amp;... args)</td></tr>
<tr class="memdesc:aaf7d6344803cdd2c500fc69195caafa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts <code>args</code> if they do not already exist in the set. If multiple values in <code>args</code> have the same type and have values that compare equivalent, and there is no such element already in the set, only the first encountered is inserted.  <a href="#aaf7d6344803cdd2c500fc69195caafa5">More...</a><br /></td></tr>
<tr class="separator:aaf7d6344803cdd2c500fc69195caafa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb9858e05bfa98608ce5f5dedcffb89"><td class="memTemplParams" colspan="2">template&lt;class T , class  = std::enable_if_t&lt;std::is_copy_constructible_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a2bb9858e05bfa98608ce5f5dedcffb89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a2bb9858e05bfa98608ce5f5dedcffb89">insert</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a2bb9858e05bfa98608ce5f5dedcffb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from the list <code>ilist</code> that do not already exist in the set. If multiple elements in the list have values that compare equivalent, and there is no such element already in the set, only the first encountered is inserted.  <a href="#a2bb9858e05bfa98608ce5f5dedcffb89">More...</a><br /></td></tr>
<tr class="separator:a2bb9858e05bfa98608ce5f5dedcffb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7ff5aaba81710bfe649d6e8932b8e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a9f7ff5aaba81710bfe649d6e8932b8e1">erase</a> (<a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a9f7ff5aaba81710bfe649d6e8932b8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element at the position pointed to by <code>pos</code> from the set.  <a href="#a9f7ff5aaba81710bfe649d6e8932b8e1">More...</a><br /></td></tr>
<tr class="separator:a9f7ff5aaba81710bfe649d6e8932b8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0359ac488a6fc12708c5b4bd88651faa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a0359ac488a6fc12708c5b4bd88651faa">erase</a> (<a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:a0359ac488a6fc12708c5b4bd88651faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements in the range [<code>first</code>, <code>last</code>).  <a href="#a0359ac488a6fc12708c5b4bd88651faa">More...</a><br /></td></tr>
<tr class="separator:a0359ac488a6fc12708c5b4bd88651faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c303c97a54cb06c2e32f4cf7550202"><td class="memTemplParams" colspan="2">template&lt;class T , class  = std::enable_if_t&lt;not (std::is_same_v&lt;const_iterator, T&gt; or std::is_same_v&lt;iterator, T&gt;)&gt;&gt; </td></tr>
<tr class="memitem:a87c303c97a54cb06c2e32f4cf7550202"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a87c303c97a54cb06c2e32f4cf7550202">erase</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a87c303c97a54cb06c2e32f4cf7550202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element from the set whose type is the same type as <code>value</code> and whose value compares equal to <code>value</code>.  <a href="#a87c303c97a54cb06c2e32f4cf7550202">More...</a><br /></td></tr>
<tr class="separator:a87c303c97a54cb06c2e32f4cf7550202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b4b02feab7c4ae295488622fd80485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a81b4b02feab7c4ae295488622fd80485">swap</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;other) noexcept(std::is_nothrow_swappable_v&lt; vector_type &gt; and std::is_nothrow_swappable_v&lt; <a class="el" href="structte_1_1CompressedPair.html">pair_type</a> &gt;)</td></tr>
<tr class="memdesc:a81b4b02feab7c4ae295488622fd80485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the set with those of other. Does not invoke any move, copy, or swap operations on individual elements. Additionally exchanges the hash functions, comparison functions, and <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a>s of the sets.  <a href="#a81b4b02feab7c4ae295488622fd80485">More...</a><br /></td></tr>
<tr class="separator:a81b4b02feab7c4ae295488622fd80485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4a188e3477bb2fd20ed77832b2eca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#abc4a188e3477bb2fd20ed77832b2eca3">update</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;other)</td></tr>
<tr class="memdesc:abc4a188e3477bb2fd20ed77832b2eca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add copies of elements from <code>other</code>.  <a href="#abc4a188e3477bb2fd20ed77832b2eca3">More...</a><br /></td></tr>
<tr class="separator:abc4a188e3477bb2fd20ed77832b2eca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cffd4ef597d50514bd84509c4ddb9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a42cffd4ef597d50514bd84509c4ddb9a">update</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a42cffd4ef597d50514bd84509c4ddb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves elements from <code>other</code> into the set.  <a href="#a42cffd4ef597d50514bd84509c4ddb9a">More...</a><br /></td></tr>
<tr class="separator:a42cffd4ef597d50514bd84509c4ddb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lookup</div></td></tr>
<tr class="memitem:a4f779a63cfdc23f956c4a969fe2787f1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4f779a63cfdc23f956c4a969fe2787f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a4f779a63cfdc23f956c4a969fe2787f1">count</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:a4f779a63cfdc23f956c4a969fe2787f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with a value that have the same type as, and compare equal to the <code>value</code>, which is either 1 or 0 since <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> does not allow duplicates.  <a href="#a4f779a63cfdc23f956c4a969fe2787f1">More...</a><br /></td></tr>
<tr class="separator:a4f779a63cfdc23f956c4a969fe2787f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745cebbb374f1ca26895758efe9d12f0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a745cebbb374f1ca26895758efe9d12f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a745cebbb374f1ca26895758efe9d12f0">find</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:a745cebbb374f1ca26895758efe9d12f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> to the element that has the same type as, and compares equal to the <code>value</code>.  <a href="#a745cebbb374f1ca26895758efe9d12f0">More...</a><br /></td></tr>
<tr class="separator:a745cebbb374f1ca26895758efe9d12f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8dfbeda6635887a184596301667241"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afc8dfbeda6635887a184596301667241"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#afc8dfbeda6635887a184596301667241">find</a> (const T &amp;value)</td></tr>
<tr class="memdesc:afc8dfbeda6635887a184596301667241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an iterator to the element that has the same type as, and compares equal to the <code>value</code>.  <a href="#afc8dfbeda6635887a184596301667241">More...</a><br /></td></tr>
<tr class="separator:afc8dfbeda6635887a184596301667241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842f26f8ec56caf35806a2345a1ec70f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a842f26f8ec56caf35806a2345a1ec70f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>, <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a842f26f8ec56caf35806a2345a1ec70f">equal_range</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:a842f26f8ec56caf35806a2345a1ec70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> range to the elements that have the same type as, and compares equal to the <code>value</code>.  <a href="#a842f26f8ec56caf35806a2345a1ec70f">More...</a><br /></td></tr>
<tr class="separator:a842f26f8ec56caf35806a2345a1ec70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a526cfab6e3e4dd20607793aa346c14"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1a526cfab6e3e4dd20607793aa346c14"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a1a526cfab6e3e4dd20607793aa346c14">equal_range</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a1a526cfab6e3e4dd20607793aa346c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an iterator range to the elements that have the same type as, and compares equal to the <code>value</code>.  <a href="#a1a526cfab6e3e4dd20607793aa346c14">More...</a><br /></td></tr>
<tr class="separator:a1a526cfab6e3e4dd20607793aa346c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f98db8233ff48a60d035be2fdcdf8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a09f98db8233ff48a60d035be2fdcdf8f">contains_value</a> (const <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> &amp;any_v) const</td></tr>
<tr class="memdesc:a09f98db8233ff48a60d035be2fdcdf8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>this</code> contains the same value as another set.  <a href="#a09f98db8233ff48a60d035be2fdcdf8f">More...</a><br /></td></tr>
<tr class="separator:a09f98db8233ff48a60d035be2fdcdf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e71e3f3d875be2fa422f5a2f7dbcad4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a7e71e3f3d875be2fa422f5a2f7dbcad4">contains_value_eq</a> (const <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> &amp;any_v) const</td></tr>
<tr class="memdesc:a7e71e3f3d875be2fa422f5a2f7dbcad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>this</code> contains the same value as another set.  <a href="#a7e71e3f3d875be2fa422f5a2f7dbcad4">More...</a><br /></td></tr>
<tr class="separator:a7e71e3f3d875be2fa422f5a2f7dbcad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6daa7e3909a5db260d005b68aeb75c2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab6daa7e3909a5db260d005b68aeb75c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ab6daa7e3909a5db260d005b68aeb75c2">contains</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:ab6daa7e3909a5db260d005b68aeb75c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>this</code> contains <code>value</code>.  <a href="#ab6daa7e3909a5db260d005b68aeb75c2">More...</a><br /></td></tr>
<tr class="separator:ab6daa7e3909a5db260d005b68aeb75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1f7f079a1a7fd7b7225f7a2fcb053c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abd1f7f079a1a7fd7b7225f7a2fcb053c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#abd1f7f079a1a7fd7b7225f7a2fcb053c">contains_eq</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:abd1f7f079a1a7fd7b7225f7a2fcb053c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>this</code> contains <code>value</code>.  <a href="#abd1f7f079a1a7fd7b7225f7a2fcb053c">More...</a><br /></td></tr>
<tr class="separator:abd1f7f079a1a7fd7b7225f7a2fcb053c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bucket Interface</div></td></tr>
<tr class="memitem:a6308245ef5e820524422bc4b743f0d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a6308245ef5e820524422bc4b743f0d3b">cbegin</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck) const</td></tr>
<tr class="memdesc:a6308245ef5e820524422bc4b743f0d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_local_iterator to the first element in the bucket at index <code>buck</code>.  <a href="#a6308245ef5e820524422bc4b743f0d3b">More...</a><br /></td></tr>
<tr class="separator:a6308245ef5e820524422bc4b743f0d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05d8e4bbd99e067be35975ae5e9437a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ab05d8e4bbd99e067be35975ae5e9437a">begin</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck) const</td></tr>
<tr class="memdesc:ab05d8e4bbd99e067be35975ae5e9437a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_local_iterator to the first element in the bucket at index <code>buck</code>.  <a href="#ab05d8e4bbd99e067be35975ae5e9437a">More...</a><br /></td></tr>
<tr class="separator:ab05d8e4bbd99e067be35975ae5e9437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32aed526754d1d08abafcf3ca927199e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a32aed526754d1d08abafcf3ca927199e">begin</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck)</td></tr>
<tr class="memdesc:a32aed526754d1d08abafcf3ca927199e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a local_iterator to the first element in the bucket at index <code>buck</code>.  <a href="#a32aed526754d1d08abafcf3ca927199e">More...</a><br /></td></tr>
<tr class="separator:a32aed526754d1d08abafcf3ca927199e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2547dfd6591204e184ed9a41a8119f99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a2547dfd6591204e184ed9a41a8119f99">cend</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck) const</td></tr>
<tr class="memdesc:a2547dfd6591204e184ed9a41a8119f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_local_iterator to the element one past the least element in the bucket at index <code>buck</code>.  <a href="#a2547dfd6591204e184ed9a41a8119f99">More...</a><br /></td></tr>
<tr class="separator:a2547dfd6591204e184ed9a41a8119f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c62381e07490eedda0fe18bf0f70ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a9c62381e07490eedda0fe18bf0f70ec2">end</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck) const</td></tr>
<tr class="memdesc:a9c62381e07490eedda0fe18bf0f70ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_local_iterator to the element one past the least element in the bucket at index <code>buck</code>.  <a href="#a9c62381e07490eedda0fe18bf0f70ec2">More...</a><br /></td></tr>
<tr class="separator:a9c62381e07490eedda0fe18bf0f70ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae18a17ec71db70fe41cd44d2b95962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a5ae18a17ec71db70fe41cd44d2b95962">end</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck)</td></tr>
<tr class="memdesc:a5ae18a17ec71db70fe41cd44d2b95962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a local_iterator to the element one past the least element in the bucket at index <code>buck</code>.  <a href="#a5ae18a17ec71db70fe41cd44d2b95962">More...</a><br /></td></tr>
<tr class="separator:a5ae18a17ec71db70fe41cd44d2b95962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06734ed66e5a868809cbe92563e3a57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:af06734ed66e5a868809cbe92563e3a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of buckets in the set.  <a href="#af06734ed66e5a868809cbe92563e3a57">More...</a><br /></td></tr>
<tr class="separator:af06734ed66e5a868809cbe92563e3a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d45dba54805315e0c4affc8ee6178d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a9d45dba54805315e0c4affc8ee6178d4">max_bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:a9d45dba54805315e0c4affc8ee6178d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum possible number of buckets in the set.  <a href="#a9d45dba54805315e0c4affc8ee6178d4">More...</a><br /></td></tr>
<tr class="separator:a9d45dba54805315e0c4affc8ee6178d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08203fd19a36ef68255105b86542eb5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a08203fd19a36ef68255105b86542eb5b">bucket_size</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck) const</td></tr>
<tr class="memdesc:a08203fd19a36ef68255105b86542eb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements in the bucket at index <code>buck</code>.  <a href="#a08203fd19a36ef68255105b86542eb5b">More...</a><br /></td></tr>
<tr class="separator:a08203fd19a36ef68255105b86542eb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61121307fc50fb15fa3e5550baad61c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae61121307fc50fb15fa3e5550baad61c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ae61121307fc50fb15fa3e5550baad61c">bucket</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:ae61121307fc50fb15fa3e5550baad61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bucket index of <code>value</code>.  <a href="#ae61121307fc50fb15fa3e5550baad61c">More...</a><br /></td></tr>
<tr class="separator:ae61121307fc50fb15fa3e5550baad61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hash Policy</div></td></tr>
<tr class="memitem:aa9139d677714107986e5380bf5163998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998">max_load_factor</a> (float f)</td></tr>
<tr class="memdesc:aa9139d677714107986e5380bf5163998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum possible number of buckets in the set.  <a href="#aa9139d677714107986e5380bf5163998">More...</a><br /></td></tr>
<tr class="separator:aa9139d677714107986e5380bf5163998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5106dea17f03564a1450f9649ba6741a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a5106dea17f03564a1450f9649ba6741a">max_load_factor</a> () const noexcept</td></tr>
<tr class="memdesc:a5106dea17f03564a1450f9649ba6741a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum allowable load factor for the set.  <a href="#a5106dea17f03564a1450f9649ba6741a">More...</a><br /></td></tr>
<tr class="separator:a5106dea17f03564a1450f9649ba6741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee36ac47b617f947a08038541f387f2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#abee36ac47b617f947a08038541f387f2">load_factor</a> () const noexcept</td></tr>
<tr class="memdesc:abee36ac47b617f947a08038541f387f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the load factor for the set.  <a href="#abee36ac47b617f947a08038541f387f2">More...</a><br /></td></tr>
<tr class="separator:abee36ac47b617f947a08038541f387f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac690ea857e56a70502d58aaf928e684e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ac690ea857e56a70502d58aaf928e684e">rehash</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> nbuckets)</td></tr>
<tr class="memdesc:ac690ea857e56a70502d58aaf928e684e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of buckets to the smallest possible value that is at least as large as <code>nbuckets</code> and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor, then the new number of buckets is at least <a class="el" href="structte_1_1AnySet.html#aa82c525d87429e9586026c549d5fca34" title="Gets the number of elements in the set, i.e. std::distance(begin(), end()). ">size()</a> / <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a>.  <a href="#ac690ea857e56a70502d58aaf928e684e">More...</a><br /></td></tr>
<tr class="separator:ac690ea857e56a70502d58aaf928e684e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dab7ac900042f7066c1ffa0b3c5375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a08dab7ac900042f7066c1ffa0b3c5375">reserve</a> (<a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html#a4f779a63cfdc23f956c4a969fe2787f1">count</a>)</td></tr>
<tr class="memdesc:a08dab7ac900042f7066c1ffa0b3c5375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of buckets to the number needed to accomodate at least <code>count</code> elements without exceeding the maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a>)).  <a href="#a08dab7ac900042f7066c1ffa0b3c5375">More...</a><br /></td></tr>
<tr class="separator:a08dab7ac900042f7066c1ffa0b3c5375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Observers</div></td></tr>
<tr class="memitem:a608c436f9887dcf4a7a7277e1ad2115e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a8d67e0b2dc842b7f6b858b974b694e4f">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a608c436f9887dcf4a7a7277e1ad2115e">hash_function</a> () const</td></tr>
<tr class="memdesc:a608c436f9887dcf4a7a7277e1ad2115e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the hash function.  <a href="#a608c436f9887dcf4a7a7277e1ad2115e">More...</a><br /></td></tr>
<tr class="separator:a608c436f9887dcf4a7a7277e1ad2115e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b7e99fd9f0725a1874533f519c3ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a8ad77e4efb4d9e761042f816af59a4a4">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a58b7e99fd9f0725a1874533f519c3ff1">key_eq</a> () const</td></tr>
<tr class="memdesc:a58b7e99fd9f0725a1874533f519c3ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the equality comparison function.  <a href="#a58b7e99fd9f0725a1874533f519c3ff1">More...</a><br /></td></tr>
<tr class="separator:a58b7e99fd9f0725a1874533f519c3ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42ca9179c0e818ae81bea5194d3a7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a034124e5f924602e12198f57f8dc18ae">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#af42ca9179c0e818ae81bea5194d3a7c9">get_allocator</a> () const</td></tr>
<tr class="memdesc:af42ca9179c0e818ae81bea5194d3a7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the allocator.  <a href="#af42ca9179c0e818ae81bea5194d3a7c9">More...</a><br /></td></tr>
<tr class="separator:af42ca9179c0e818ae81bea5194d3a7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Node Interface</div></td></tr>
<tr class="memitem:a65ce349ff5b24b0496c87a3fe7a3a997"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>, <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a65ce349ff5b24b0496c87a3fe7a3a997">pop</a> (<a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos_)</td></tr>
<tr class="memdesc:a65ce349ff5b24b0496c87a3fe7a3a997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the element at the position pointed to by <code>pos</code> from the set.  <a href="#a65ce349ff5b24b0496c87a3fe7a3a997">More...</a><br /></td></tr>
<tr class="separator:a65ce349ff5b24b0496c87a3fe7a3a997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e29e8eb2ac4ec9e5d3b1da300b50290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a9e29e8eb2ac4ec9e5d3b1da300b50290">dup</a> (<a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos) const</td></tr>
<tr class="memdesc:a9e29e8eb2ac4ec9e5d3b1da300b50290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and return the element at the position pointed to by <code>pos</code>.  <a href="#a9e29e8eb2ac4ec9e5d3b1da300b50290">More...</a><br /></td></tr>
<tr class="separator:a9e29e8eb2ac4ec9e5d3b1da300b50290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e24b473f4e5302c7bf6d501be97df51"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, <a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a2e24b473f4e5302c7bf6d501be97df51">push</a> (<a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> &amp;&amp;node)</td></tr>
<tr class="memdesc:a2e24b473f4e5302c7bf6d501be97df51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the value pointed to by <code>node</code> to <code>this</code>.  <a href="#a2e24b473f4e5302c7bf6d501be97df51">More...</a><br /></td></tr>
<tr class="separator:a2e24b473f4e5302c7bf6d501be97df51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7420d89b8635801e053854c862f40ce"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ab7420d89b8635801e053854c862f40ce">splice</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;other, <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ab7420d89b8635801e053854c862f40ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the element at position <code>pos</code> from <code>other</code> into <code>this</code>.  <a href="#ab7420d89b8635801e053854c862f40ce">More...</a><br /></td></tr>
<tr class="separator:ab7420d89b8635801e053854c862f40ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab598afce723f1e27452bab44f41410a1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#ab598afce723f1e27452bab44f41410a1">splice</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;other, <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:ab598afce723f1e27452bab44f41410a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in the range [first, last) from <code>other</code> into <code>this</code>.  <a href="#ab598afce723f1e27452bab44f41410a1">More...</a><br /></td></tr>
<tr class="separator:ab598afce723f1e27452bab44f41410a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305ff8b8218ab15ef6f04395ff298162"><td class="memTemplParams" colspan="2">template&lt;class T , class  = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, self_type&gt;&gt;&gt; </td></tr>
<tr class="memitem:a305ff8b8218ab15ef6f04395ff298162"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a305ff8b8218ab15ef6f04395ff298162">splice_or_copy</a> (T &amp;&amp;other, <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> last) -&gt; std::pair&lt; decltype(other.begin()), decltype(other.begin())&gt;</td></tr>
<tr class="memdesc:a305ff8b8218ab15ef6f04395ff298162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies or moves the elements in the range [first, last) from <code>other</code> into <code>this</code>.  <a href="#a305ff8b8218ab15ef6f04395ff298162">More...</a><br /></td></tr>
<tr class="separator:a305ff8b8218ab15ef6f04395ff298162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee90ef4d5c25620f52a1bcb1e7de9be"><td class="memTemplParams" colspan="2">template&lt;class T , class  = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, self_type&gt;&gt;&gt; </td></tr>
<tr class="memitem:a1ee90ef4d5c25620f52a1bcb1e7de9be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a1ee90ef4d5c25620f52a1bcb1e7de9be">splice_or_copy</a> (T &amp;&amp;other, <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos) -&gt; std::tuple&lt; <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, decltype(other.begin()), bool &gt;</td></tr>
<tr class="memdesc:a1ee90ef4d5c25620f52a1bcb1e7de9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies or moves the element at position <code>pos</code> from <code>other</code> into <code>this</code>.  <a href="#a1ee90ef4d5c25620f52a1bcb1e7de9be">More...</a><br /></td></tr>
<tr class="separator:a1ee90ef4d5c25620f52a1bcb1e7de9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Non-Member functions</div></td></tr>
<tr class="memitem:a074e520f91cc54b3df3d1278c9944367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a074e520f91cc54b3df3d1278c9944367">swap</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;left, <a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;right)</td></tr>
<tr class="memdesc:a074e520f91cc54b3df3d1278c9944367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls left.swap(right).  <a href="#a074e520f91cc54b3df3d1278c9944367">More...</a><br /></td></tr>
<tr class="separator:a074e520f91cc54b3df3d1278c9944367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0195a9b300310dd1d599faec16f9c8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#aa0195a9b300310dd1d599faec16f9c8c">operator==</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;right)</td></tr>
<tr class="memdesc:aa0195a9b300310dd1d599faec16f9c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the contents of two sets.  <a href="#aa0195a9b300310dd1d599faec16f9c8c">More...</a><br /></td></tr>
<tr class="separator:aa0195a9b300310dd1d599faec16f9c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c46f2275e85ea21dfd2919fe0981fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html#a37c46f2275e85ea21dfd2919fe0981fd">operator!=</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a> &amp;right)</td></tr>
<tr class="memdesc:a37c46f2275e85ea21dfd2919fe0981fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the contents of two sets.  <a href="#a37c46f2275e85ea21dfd2919fe0981fd">More...</a><br /></td></tr>
<tr class="separator:a37c46f2275e85ea21dfd2919fe0981fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4c2cffe66078db7aa7916cdac9badfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2cffe66078db7aa7916cdac9badfc6">&#9670;&nbsp;</a></span>node_handle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> =  std::unique_ptr&lt;<a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Node type to allow elements to persist after being removed, and for splicing between <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a966efeede2c85ea0e11b7af0366119ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966efeede2c85ea0e11b7af0366119ec">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashFn &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>HashFn()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">hash</td><td>- Hash function to initialize the set with. </td></tr>
    <tr><td class="paramname">equal</td><td>- Equality comparison function to initialize the set with. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a64b737fb06974c4658dff89717f252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a64b737fb06974c4658dff89717f252">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a158e154a3d03b13e4a035342bfe70569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158e154a3d03b13e4a035342bfe70569">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashFn &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">hash</td><td>- Hash function to initialize the set with. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4e3a32bb198fb9a4de9a8917c1123f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e3a32bb198fb9a4de9a8917c1123f2">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashFn &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>HashFn()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the range [first, last). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the range compare equivalent, only the first encountered is inserted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>- Input iterator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- Iterator to the first element in the range. </td></tr>
    <tr><td class="paramname">last</td><td>- Iterator one position past the last element in the range. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">hash</td><td>- Hash function to initialize the set with. </td></tr>
    <tr><td class="paramname">equal</td><td>- Equality comparison function to initialize the set with </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e098e80fdf2b2192319ff76d601a1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e098e80fdf2b2192319ff76d601a1c3">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the range [first, last). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the range compare equivalent, only the first encountered is inserted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>- Input iterator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- Iterator to the first element in the range. </td></tr>
    <tr><td class="paramname">last</td><td>- Iterator one position past the last element in the range. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b1df747c2198efd5efe5ba16bfb314d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1df747c2198efd5efe5ba16bfb314d">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashFn &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the range [first, last). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the range compare equivalent, only the first encountered is inserted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>- Input iterator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- Iterator to the first element in the range. </td></tr>
    <tr><td class="paramname">last</td><td>- Iterator one position past the last element in the range. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">hash</td><td>- Hash function to initialize the set with. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc47a853ec464d1e32b53b9747156747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc47a853ec464d1e32b53b9747156747">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from other. Constructs the set with the copy of the contents of other. Copies the load factor, the predicate, and the hash function as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set whose contents will be copied. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6aa2884c8d394bf7eeb6459224307c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6aa2884c8d394bf7eeb6459224307c6">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from other. Constructs the set with the copy of the contents of other. Copies the load factor, the predicate, and the hash function as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set whose contents will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a226874c61eb1eb38eee1f2ce0ab990a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226874c61eb1eb38eee1f2ce0ab990a4">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from other. Constructs the set with the copy of the contents of other. Copies the load factor, the predicate, and the hash function as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set whose contents will be copied. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65383e7f9deaaa338bf4a016a7106f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65383e7f9deaaa338bf4a016a7106f72">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from other. Constructs the set with the copy of the contents of other. Copies the load factor, the predicate, and the hash function as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set whose contents will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a584bb61c6139493b3ca4859d261d09e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584bb61c6139493b3ca4859d261d09e6">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashFn &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>HashFn()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the initializer list ilist. Same as <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>(init.begin(), init.end()). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the list compare equivalent, only the first encountered is inserted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type of the elements in the initializer list which will be added to the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>- Initializer list to initialize the elements of the set with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">hash</td><td>- Hash function to initialize the set with. </td></tr>
    <tr><td class="paramname">equal</td><td>- Equality comparison function to initialize the set with </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd1bc5833fb79e44ef1dcdd5e3c88bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1bc5833fb79e44ef1dcdd5e3c88bcf">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the initializer list ilist. Same as <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>(init.begin(), init.end()). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the list compare equivalent, only the first encountered is inserted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type of the elements in the initializer list which will be added to the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>- Initializer list to initialize the elements of the set with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa168fffe9f11ad2ebde217740baa1cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa168fffe9f11ad2ebde217740baa1cbf">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashFn &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the initializer list ilist. Same as <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>(init.begin(), init.end()). Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the list compare equivalent, only the first encountered is inserted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type of the elements in the initializer list which will be added to the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>- Initializer list to initialize the elements of the set with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">hash</td><td>- Hash function to initialize the set with. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15ab2e1618e11f308fee56d1e840b603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ab2e1618e11f308fee56d1e840b603">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; T ... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>2&#160;*&#160;(sizeof...(T))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashFn &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>HashFn()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the tuple tup. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the tuple have the same type and compare equivalent,only the first encountered is inserted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Parameter pack types of the tuple elements that will be used to initialize the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>- Initializer list to initialize the elements of the set with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">hash</td><td>- Hash function to initialize the set with. </td></tr>
    <tr><td class="paramname">equal</td><td>- Equality comparison function to initialize the set with </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0366d2d6867776b8ebfacaa167b4a5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0366d2d6867776b8ebfacaa167b4a5b0">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; T ... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the tuple tup. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the tuple have the same type and compare equivalent,only the first encountered is inserted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Parameter pack types of the tuple elements that will be used to initialize the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>- Initializer list to initialize the elements of the set with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadd6af9b081ad61a07e81090334614e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd6af9b081ad61a07e81090334614e2">&#9670;&nbsp;</a></span>AnySet() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::<a class="el" href="structte_1_1AnySet.html">AnySet</a> </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; T ... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashFn &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> with the contents of the tuple tup. Sets <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> to 1.0. If multiple elements in the tuple have the same type and compare equivalent,only the first encountered is inserted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Parameter pack types of the tuple elements that will be used to initialize the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>- Initializer list to initialize the elements of the set with. </td></tr>
    <tr><td class="paramname">bucket_count</td><td>- Minimum number of buckets to initialize the set with. </td></tr>
    <tr><td class="paramname">hash</td><td>- Hash function to initialize the set with. </td></tr>
    <tr><td class="paramname">alloc</td><td>- Allocator to initialize the set with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88d77aa672a65bf4adf8f7811ea8180b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d77aa672a65bf4adf8f7811ea8180b">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> to the first element in the set. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> to the first element in the set. </dd></dl>

</div>
</div>
<a id="a48961e895f29eb637b40166f2ad94d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48961e895f29eb637b40166f2ad94d00">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a iterator to the first element in the set. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element in the set. </dd></dl>

</div>
</div>
<a id="ab05d8e4bbd99e067be35975ae5e9437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05d8e4bbd99e067be35975ae5e9437a">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>buck</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_local_iterator to the first element in the bucket at index <code>buck</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buck</td><td>- Index of the bucket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_local_iterator to the first element in the bucket at index <code>buck</code>. </dd></dl>

</div>
</div>
<a id="a32aed526754d1d08abafcf3ca927199e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32aed526754d1d08abafcf3ca927199e">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">local_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>buck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a local_iterator to the first element in the bucket at index <code>buck</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buck</td><td>- Index of the bucket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local_iterator to the first element in the bucket at index <code>buck</code>. </dd></dl>

</div>
</div>
<a id="ae61121307fc50fb15fa3e5550baad61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61121307fc50fb15fa3e5550baad61c">&#9670;&nbsp;</a></span>bucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bucket index of <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- Value whose bucket is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the bucket in which <code>value</code> belongs. </dd></dl>

</div>
</div>
<a id="af06734ed66e5a868809cbe92563e3a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06734ed66e5a868809cbe92563e3a57">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of buckets in the set. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of buckets in the set. </dd></dl>

</div>
</div>
<a id="a08203fd19a36ef68255105b86542eb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08203fd19a36ef68255105b86542eb5b">&#9670;&nbsp;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>buck</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of elements in the bucket at index <code>buck</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buck</td><td>- Index of the bucket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the bucket. </dd></dl>

</div>
</div>
<a id="a4573f5334af88c606b3f73da6c6c0916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4573f5334af88c606b3f73da6c6c0916">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> to the first element in the set. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> to the first element in the set. </dd></dl>

</div>
</div>
<a id="a6308245ef5e820524422bc4b743f0d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6308245ef5e820524422bc4b743f0d3b">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>buck</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_local_iterator to the first element in the bucket at index <code>buck</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buck</td><td>- Index of the bucket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_local_iterator to the first element in the bucket at index <code>buck</code>. </dd></dl>

</div>
</div>
<a id="a60ea6c78bad173c6f63152992efa364a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ea6c78bad173c6f63152992efa364a">&#9670;&nbsp;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a past-the-end <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> for this set. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> 1 past the last element in the set. </dd></dl>

</div>
</div>
<a id="a2547dfd6591204e184ed9a41a8119f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2547dfd6591204e184ed9a41a8119f99">&#9670;&nbsp;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>buck</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_local_iterator to the element one past the least element in the bucket at index <code>buck</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buck</td><td>- Index of the bucket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_local_iterator to the element one past the least element in the bucket at index <code>buck</code>. </dd></dl>

</div>
</div>
<a id="ab6daa7e3909a5db260d005b68aeb75c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6daa7e3909a5db260d005b68aeb75c2">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>this</code> contains <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- Value to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this set contains an element whose type as is the same as <code>values's</code> type and whose value compares equal to <code>value</code> using the KeyEqual comparator. </dd></dl>

</div>
</div>
<a id="abd1f7f079a1a7fd7b7225f7a2fcb053c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1f7f079a1a7fd7b7225f7a2fcb053c">&#9670;&nbsp;</a></span>contains_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::contains_eq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>this</code> contains <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- Value to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this set contains an element whose type as is the same as <code>value's</code> type and whose value compares equal to <code>value</code> using <a class="el" href="structte_1_1AnySet.html#aa0195a9b300310dd1d599faec16f9c8c" title="Compare the contents of two sets. ">operator==()</a>. </dd></dl>

</div>
</div>
<a id="a09f98db8233ff48a60d035be2fdcdf8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f98db8233ff48a60d035be2fdcdf8f">&#9670;&nbsp;</a></span>contains_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::contains_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>any_v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>this</code> contains the same value as another set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt;Hash, KeyEqual&gt; instance to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this set contains an element whose type as is the same as <code>any_v's</code> value's type and whose value compares equal to the value of <code>any_v</code> using the KeyEqual comparator. </dd></dl>

</div>
</div>
<a id="a7e71e3f3d875be2fa422f5a2f7dbcad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e71e3f3d875be2fa422f5a2f7dbcad4">&#9670;&nbsp;</a></span>contains_value_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::contains_value_eq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>any_v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>this</code> contains the same value as another set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt;Hash, KeyEqual&gt; instance to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this set contains an element whose type as is the same as <code>any_v's</code> value's type and whose value compares equal to the value of <code>any_v</code> using <a class="el" href="structte_1_1AnySet.html#aa0195a9b300310dd1d599faec16f9c8c" title="Compare the contents of two sets. ">operator==()</a>. </dd></dl>

</div>
</div>
<a id="a4f779a63cfdc23f956c4a969fe2787f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f779a63cfdc23f956c4a969fe2787f1">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with a value that have the same type as, and compare equal to the <code>value</code>, which is either 1 or 0 since <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> does not allow duplicates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- The value to obtain the count of in the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements found. </dd></dl>

</div>
</div>
<a id="a9e29e8eb2ac4ec9e5d3b1da300b50290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e29e8eb2ac4ec9e5d3b1da300b50290">&#9670;&nbsp;</a></span>dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy and return the element at the position pointed to by <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- Iterator to the element to pop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A node_handle that points to the copied element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the value at <code>pos</code> is an instance of a type that does not satisfy CopyConstructible, this function throws a <a class="el" href="structte_1_1NoCopyConstructorError.html" title="Exception thrown when attempting to make copies of an AnyValue instance that contains an instance of ...">te::NoCopyConstructorError</a>. </dd></dl>

</div>
</div>
<a id="ae1714daaedbc435c19d0bd94320a3d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1714daaedbc435c19d0bd94320a3d15">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T , class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the same type and value in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>- Arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type of the element to emplace. Must be a constructible non-reference type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place. true for insertion, false for no insertion.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> follows the convention of STL node-based containers where emplacement is implemented by first allocating a new node, constructing the element within the allocated node, and <em>then</em> inserting. This means that <a class="el" href="structte_1_1AnySet.html#ae1714daaedbc435c19d0bd94320a3d15" title="Inserts a new element into the container constructed in-place with the given args if there is no elem...">AnySet::emplace()</a> allocates a node even when insertion fails (i.e. the element already exists in the set).</dd></dl>
<p>Emplacement is the only way of inserting objects of non-movable, non-copyable types into an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance.</p>
<dl class="section note"><dt>Note</dt><dd>References, pointers, and iterators remain valid after emplacement, however the values pointed to by iterators may change. </dd></dl>

</div>
</div>
<a id="ae5e4dcb2691ff7bca954aa1b6e8a7f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e4dcb2691ff7bca954aa1b6e8a7f3d">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T , class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the same type and value in the container, using an iterator hint as a suggestion for where the new element should be placed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type of the element to emplace. Must be a constructible non-reference type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>- Arguments to forward to the constructor of the element. </td></tr>
    <tr><td class="paramname">hint</td><td>- Iterator, used as a suggestion as to where to insert the new element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place. true for insertion, false for no insertion.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This member function is provided for consistency. The <code>hint</code> argument is ignored and instead this function simply calls <a class="el" href="structte_1_1AnySet.html#ae1714daaedbc435c19d0bd94320a3d15" title="Inserts a new element into the container constructed in-place with the given args if there is no elem...">AnySet::emplace&lt;T&gt;</a>(forward&lt;Args&gt;(args)...).</dd></dl>
<p><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> follows the convention of STL node-based containers where emplacement is implemented by first allocating a new node, constructing the element within the allocated node, and <em>then</em> inserting. This means that <a class="el" href="structte_1_1AnySet.html#ae1714daaedbc435c19d0bd94320a3d15" title="Inserts a new element into the container constructed in-place with the given args if there is no elem...">AnySet::emplace()</a> allocates a node even when insertion fails (i.e. the element already exists in the set).</p>
<p>Emplacement is the only way of inserting objects of non-movable, non-copyable types into an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance.</p>
<dl class="section note"><dt>Note</dt><dd>References, pointers, and iterators remain valid after emplacement, however the values pointed to by iterators may change. </dd></dl>

</div>
</div>
<a id="a393e3a7a552f2d5cda17ee0bfa0a251e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393e3a7a552f2d5cda17ee0bfa0a251e">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set has no elements, i.e. whether <a class="el" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00" title="Get a iterator to the first element in the set. ">begin()</a> == <a class="el" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64" title="Get a past-the-end iterator for this set. ">end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the set is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a6f4e76a019d6e5e20c66ef9c32d6b3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4e76a019d6e5e20c66ef9c32d6b3ee">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a past-the-end <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> for this set. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> 1 past the last element in the set. </dd></dl>

</div>
</div>
<a id="a730117cbdfa732d5739dcaedd99eaf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730117cbdfa732d5739dcaedd99eaf64">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a past-the-end iterator for this set. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator 1 past the last element in the set. </dd></dl>

</div>
</div>
<a id="a9c62381e07490eedda0fe18bf0f70ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c62381e07490eedda0fe18bf0f70ec2">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>buck</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_local_iterator to the element one past the least element in the bucket at index <code>buck</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buck</td><td>- Index of the bucket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_local_iterator to the element one past the least element in the bucket at index <code>buck</code>. </dd></dl>

</div>
</div>
<a id="a5ae18a17ec71db70fe41cd44d2b95962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae18a17ec71db70fe41cd44d2b95962">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">local_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>buck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a local_iterator to the element one past the least element in the bucket at index <code>buck</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buck</td><td>- Index of the bucket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local_iterator to the element one past the least element in the bucket at index <code>buck</code>. </dd></dl>

</div>
</div>
<a id="a842f26f8ec56caf35806a2345a1ec70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842f26f8ec56caf35806a2345a1ec70f">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>, <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> range to the elements that have the same type as, and compares equal to the <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- The value to obtain find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair containing a pair of const_iterators defining the requested range. If there are no such elements, past-the-end (see <a class="el" href="structte_1_1AnySet.html#a60ea6c78bad173c6f63152992efa364a" title="Get a past-the-end const_iterator for this set. ">cend()</a>) const_iterators are returned as both elements of the pair. </dd></dl>

</div>
</div>
<a id="a1a526cfab6e3e4dd20607793aa346c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a526cfab6e3e4dd20607793aa346c14">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain an iterator range to the elements that have the same type as, and compares equal to the <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- The value to obtain find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair containing a pair of iterators defining the requested range. If there are no such elements, past-the-end (see <a class="el" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64" title="Get a past-the-end iterator for this set. ">end()</a>) iterators are returned as both elements of the pair. </dd></dl>

</div>
</div>
<a id="a9f7ff5aaba81710bfe649d6e8932b8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7ff5aaba81710bfe649d6e8932b8e1">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the element at the position pointed to by <code>pos</code> from the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- Iterator to the element to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the erased element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike std::unordered_set, erasure invalidates only iterators to the element following the erased element. The iterator returned by <a class="el" href="structte_1_1AnySet.html#a9f7ff5aaba81710bfe649d6e8932b8e1" title="Remove the element at the position pointed to by pos from the set. ">erase()</a> is a suitable replacement for the invalidated iterator. </dd></dl>

</div>
</div>
<a id="a0359ac488a6fc12708c5b4bd88651faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0359ac488a6fc12708c5b4bd88651faa">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove elements in the range [<code>first</code>, <code>last</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- Iterator to the first element in the range to erase. </td></tr>
    <tr><td class="paramname">last</td><td>- Iterator one position past the last element to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last erased element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike std::unordered_set, erasure invalidates only iterators to the element following the erased element. The iterator returned by <a class="el" href="structte_1_1AnySet.html#a9f7ff5aaba81710bfe649d6e8932b8e1" title="Remove the element at the position pointed to by pos from the set. ">erase()</a> is a suitable replacement for the invalidated iterator.</dd>
<dd>
For range-erasure, this specifically means that the returned iterator is a suitable replacement for iterators equivalent to the <code>last</code> parameter. </dd></dl>

</div>
</div>
<a id="a87c303c97a54cb06c2e32f4cf7550202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c303c97a54cb06c2e32f4cf7550202">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T , class  = std::enable_if_t&lt;not (std::is_same_v&lt;const_iterator, T&gt; or std::is_same_v&lt;iterator, T&gt;)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the element from the set whose type is the same type as <code>value</code> and whose value compares equal to <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- Value of the element to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements erased (zero or one).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike std::unordered_set, erasure invalidates only iterators to the element following the erased element. The iterator returned by <a class="el" href="structte_1_1AnySet.html#a9f7ff5aaba81710bfe649d6e8932b8e1" title="Remove the element at the position pointed to by pos from the set. ">erase()</a> is a suitable replacement for the invalidated iterator. </dd></dl>

</div>
</div>
<a id="a745cebbb374f1ca26895758efe9d12f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745cebbb374f1ca26895758efe9d12f0">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> to the element that has the same type as, and compares equal to the <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- The value to obtain find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a> to the element found, or this-&gt;<a class="el" href="structte_1_1AnySet.html#a60ea6c78bad173c6f63152992efa364a" title="Get a past-the-end const_iterator for this set. ">cend()</a> if no such element exists. </dd></dl>

</div>
</div>
<a id="afc8dfbeda6635887a184596301667241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8dfbeda6635887a184596301667241">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain an iterator to the element that has the same type as, and compares equal to the <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- The value to obtain find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element found, or this-&gt;<a class="el" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64" title="Get a past-the-end iterator for this set. ">end()</a> if no such element exists. </dd></dl>

</div>
</div>
<a id="af42ca9179c0e818ae81bea5194d3a7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42ca9179c0e818ae81bea5194d3a7c9">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a034124e5f924602e12198f57f8dc18ae">allocator_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the allocator. </dd></dl>

</div>
</div>
<a id="a608c436f9887dcf4a7a7277e1ad2115e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608c436f9887dcf4a7a7277e1ad2115e">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a8d67e0b2dc842b7f6b858b974b694e4f">hasher</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the hash function. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of hash function. </dd></dl>

</div>
</div>
<a id="a9e113b687669fcc70d2aab15581eba4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e113b687669fcc70d2aab15581eba4b">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into the set, if the set doesn't already contain an element with an equivalent value and type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place. true for insertion, false for no insertion.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>References, pointers, and iterators remain valid after insertion, however the values pointed to by iterators may change. </dd></dl>

</div>
</div>
<a id="af5963685181390d0b2730e401a38998c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5963685181390d0b2730e401a38998c">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into the set, if the set doesn't already contain an element with an equivalent value and type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place. true for insertion, false for no insertion.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This member function is provided for consistency. The <code>hint</code> argument is ignored and instead this function simply calls AnySet::insert&lt;T&gt;(forward&lt;T&gt;(value)).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>References, pointers, and iterators remain valid after insertion, however the values pointed to by iterators may change. </dd></dl>

</div>
</div>
<a id="ab6777a564b3a11d8e0eb3936f1f98376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6777a564b3a11d8e0eb3936f1f98376">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class It , class  = std::enable_if_t&lt;			std::is_copy_constructible_v&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;			or std::is_rvalue_reference_v&lt;decltype(*std::declval&lt;It&gt;())&gt;		&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from the range [first, last) that do not already exist in the set. If multiple elements in the range have values that compare equivalent, and there is no such element already in the set, only the first encountered is inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- Iterator to first element in the range. </td></tr>
    <tr><td class="paramname">last</td><td>- Iterator one position past the last element in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Range insertion assumes that all elements in the range [first, last) do not already exist in the set and will preemptively reallocate the internal bucket array accordingly to satisfy the current <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a> if <code>first</code> and <code>last</code> are not input iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>References, pointers, and iterators remain valid after insertion, however the values pointed to by iterators may change. </dd></dl>

</div>
</div>
<a id="aaf7d6344803cdd2c500fc69195caafa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7d6344803cdd2c500fc69195caafa5">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T , class U , class ... V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt;2ull + sizeof...(V)&gt; te::AnySet&lt; HashFn, KeyEqual, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts <code>args</code> if they do not already exist in the set. If multiple values in <code>args</code> have the same type and have values that compare equivalent, and there is no such element already in the set, only the first encountered is inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- first value to insert into the set. </td></tr>
    <tr><td class="paramname">second</td><td>- second value to insert into the set. </td></tr>
    <tr><td class="paramname">args</td><td>- subsequent values to insert into the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Variadic argument insertion assumes that all of the arguments do not already exist in the set and will preemptively reallocate the internal bucket array accordingly to satisfy the current <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bitset where the ith bit is set to <code>true</code> iff the ith argument was successfully inserted.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>References, pointers, and iterators remain valid after insertion, however the values pointed to by iterators may change. </dd></dl>

</div>
</div>
<a id="a2bb9858e05bfa98608ce5f5dedcffb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb9858e05bfa98608ce5f5dedcffb89">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T , class  = std::enable_if_t&lt;std::is_copy_constructible_v&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from the list <code>ilist</code> that do not already exist in the set. If multiple elements in the list have values that compare equivalent, and there is no such element already in the set, only the first encountered is inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>- Initializer list of elements to insert into the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Initializer-list insertion assumes that all elements in the list do not already exist in the set and will preemptively reallocate the internal bucket array accordingly to satisfy the current <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of values successfully inserted.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>References, pointers, and iterators remain valid after insertion, however the values pointed to by iterators may change. </dd></dl>

</div>
</div>
<a id="a58b7e99fd9f0725a1874533f519c3ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b7e99fd9f0725a1874533f519c3ff1">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a8ad77e4efb4d9e761042f816af59a4a4">key_equal</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the equality comparison function. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the equality comparison function. </dd></dl>

</div>
</div>
<a id="abee36ac47b617f947a08038541f387f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee36ac47b617f947a08038541f387f2">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the load factor for the set. </p>
<dl class="section return"><dt>Returns</dt><dd>The load factor for the set. </dd></dl>

</div>
</div>
<a id="a9d45dba54805315e0c4affc8ee6178d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d45dba54805315e0c4affc8ee6178d4">&#9670;&nbsp;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum possible number of buckets in the set. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum possible number of buckets in the set. </dd></dl>

</div>
</div>
<a id="aa9139d677714107986e5380bf5163998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9139d677714107986e5380bf5163998">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum possible number of buckets in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- The new load factor. Must be a positive number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum possible number of buckets in the set. </dd></dl>

</div>
</div>
<a id="a5106dea17f03564a1450f9649ba6741a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5106dea17f03564a1450f9649ba6741a">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum allowable load factor for the set. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowable load factor for the set. </dd></dl>

</div>
</div>
<a id="a8ca85fcaf35763f2339e77bbf93f505e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca85fcaf35763f2339e77bbf93f505e">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00" title="Get a iterator to the first element in the set. ">begin()</a>, <a class="el" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64" title="Get a past-the-end iterator for this set. ">end()</a>) for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

</div>
</div>
<a id="aadc20b7c67d5c635b2c54b9b2f00ae40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc20b7c67d5c635b2c54b9b2f00ae40">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assigns the contents of this <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the contents of other. Copies the load factor, the predicate, the hash function, and allocator as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set whose contents will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structte_1_1NoCopyConstructorError.html" title="Exception thrown when attempting to make copies of an AnyValue instance that contains an instance of ...">te::NoCopyConstructorError</a></td><td>if <code>other</code> contains an element of non-copy-constructible type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this; </dd></dl>

</div>
</div>
<a id="acf3ff8ce9e70828b4240a67129eb5e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3ff8ce9e70828b4240a67129eb5e83">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assigns the contents of this <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance from the contents of other. Moves the load factor, the predicate, the hash function, and allocator as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set whose contents will be moved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this; </dd></dl>

</div>
</div>
<a id="aada8bfe6c1bbc1e2300d8eeaf6621c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada8bfe6c1bbc1e2300d8eeaf6621c1b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the contents of this <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance with the contents of ilist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>- The initializer list whose contents will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this; </dd></dl>

</div>
</div>
<a id="a65ce349ff5b24b0496c87a3fe7a3a997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ce349ff5b24b0496c87a3fe7a3a997">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>, <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and return the element at the position pointed to by <code>pos</code> from the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- Iterator to the element to pop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair whose first member is a node_handle that points to the removed element, and whose second member is an iterator to the element following the popped element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invalidates any iterators to the element after the popped element. Use the iterator returned by this function in place of those. Iterators to the popped element will point to the element after the popped element and are not invalidated. If the returned node_handle is subsequently added to a set by calling '<a class="el" href="structte_1_1AnySet.html#a2e24b473f4e5302c7bf6d501be97df51" title="Insert the value pointed to by node to this. ">push()</a>' any invalidated iterators are subsequently "re-validated", but will point to a (possibly past-the-end) element in the set in which the node_handle was pushed. </dd></dl>

</div>
</div>
<a id="a2e24b473f4e5302c7bf6d501be97df51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e24b473f4e5302c7bf6d501be97df51">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, <a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the value pointed to by <code>node</code> to <code>this</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>- node_handle pointing to the element to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair whose first member is an iterator to the inserted node or the the element that prevented the insertion, and a node_handle that points to null if the insertion was successful, or <code>node</code> if it was unsuccessful. In otherwords, the caller gets the node back only if it couldn't be inserted.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No iterators are invalidated. </dd></dl>

</div>
</div>
<a id="ac690ea857e56a70502d58aaf928e684e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac690ea857e56a70502d58aaf928e684e">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>nbuckets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of buckets to the smallest possible value that is at least as large as <code>nbuckets</code> and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor, then the new number of buckets is at least <a class="el" href="structte_1_1AnySet.html#aa82c525d87429e9586026c549d5fca34" title="Gets the number of elements in the set, i.e. std::distance(begin(), end()). ">size()</a> / <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbuckets</td><td>- The new number of buckets in the container after rehashing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The current implementation uses only powers-of-two for the bucket count. </dd></dl>

</div>
</div>
<a id="a08dab7ac900042f7066c1ffa0b3c5375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dab7ac900042f7066c1ffa0b3c5375">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of buckets to the number needed to accomodate at least <code>count</code> elements without exceeding the maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a>)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>- The number of elements to reserve space for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The current implementation uses only powers-of-two for the bucket count. </dd></dl>

</div>
</div>
<a id="aa82c525d87429e9586026c549d5fca34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82c525d87429e9586026c549d5fca34">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of elements in the set, i.e. std::distance(<a class="el" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00" title="Get a iterator to the first element in the set. ">begin()</a>, <a class="el" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64" title="Get a past-the-end iterator for this set. ">end()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the set. </dd></dl>

</div>
</div>
<a id="ab7420d89b8635801e053854c862f40ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7420d89b8635801e053854c862f40ce">&#9670;&nbsp;</a></span>splice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the element at position <code>pos</code> from <code>other</code> into <code>this</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set to move the element from. </td></tr>
    <tr><td class="paramname">pos</td><td>- Iterator to the element to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::tuple whose first member is an iterator to the position in <code>this</code> where the element was inserted or the element that prevented the insertion, whose second member is an iterator to the position in <code>other</code> of the element after the element at position <code>pos</code>, and whose third member is a bool indicating whether the move occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No iterators are invalidated by this function.</dd>
<dd>
No element copy or move constructors are invoked by this function. The element is moved by splicing internal node objects from <code>other</code> into <code>this</code>.</dd>
<dd>
If an exception is thrown due to a failure to allocate enough buckets for the new element, both <code>this</code> and <code>other</code> are unmodified. (conditional rollback semantics) </dd></dl>

</div>
</div>
<a id="ab598afce723f1e27452bab44f41410a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab598afce723f1e27452bab44f41410a1">&#9670;&nbsp;</a></span>splice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, <a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&gt; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements in the range [first, last) from <code>other</code> into <code>this</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set to move the element from. </td></tr>
    <tr><td class="paramname">first</td><td>- Iterator to the first element to move. </td></tr>
    <tr><td class="paramname">last</td><td>- Iterator to the element after the last element to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator range to the elements in <code>other</code>, that were <em>not</em> moved into <code>this</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No iterators are invalidated by this function.</dd>
<dd>
No element copy or move constructors are invoked by this function. The element is moved by splicing internal node objects from <code>other</code> into <code>this</code>.</dd>
<dd>
If an exception is thrown due to a failure to allocate enough buckets for the new element, both <code>this</code> and <code>other</code> are unmodified. (conditional rollback semantics) </dd></dl>

</div>
</div>
<a id="a305ff8b8218ab15ef6f04395ff298162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305ff8b8218ab15ef6f04395ff298162">&#9670;&nbsp;</a></span>splice_or_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T , class  = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, self_type&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::splice_or_copy </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::pair&lt;decltype(other.begin()), decltype(other.begin())&gt; 
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies or moves the elements in the range [first, last) from <code>other</code> into <code>this</code>. </p>
<p>Elements are only moved from <code>other</code> if <code>other</code> is an rvalue reference to non-const. If <code>other</code> is a reference to const <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>, then elements are copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set to move the element from. </td></tr>
    <tr><td class="paramname">first</td><td>- Iterator to the first element to move. </td></tr>
    <tr><td class="paramname">last</td><td>- Iterator to the element after the last element to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator range to the elements in <code>other</code>, that were <em>not</em> moved into <code>this</code>. If <code>other</code> is not an rvalue, no elements are moved and thus the returned range is simple [first, last).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No iterators are invalidated by this function.</dd>
<dd>
No element copy or move constructors are invoked by this function. The element is moved by splicing internal node objects from <code>other</code> into <code>this</code>.</dd>
<dd>
If an exception is thrown due to a failure to allocate enough buckets for the new element, both <code>this</code> and <code>other</code> are unmodified. (conditional rollback semantics)</dd>
<dd>
If <code>other</code> is const and any value in the range [<code>first</code>, <code>last</code>) is an instance of a type that does not satisfy CopyConstructible, this function throws a <a class="el" href="structte_1_1NoCopyConstructorError.html" title="Exception thrown when attempting to make copies of an AnyValue instance that contains an instance of ...">te::NoCopyConstructorError</a>. If this occurs, only the elements preceding that value will have been added to <code>this</code>. </dd></dl>

</div>
</div>
<a id="a1ee90ef4d5c25620f52a1bcb1e7de9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee90ef4d5c25620f52a1bcb1e7de9be">&#9670;&nbsp;</a></span>splice_or_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T , class  = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, self_type&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::splice_or_copy </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;<a class="el" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, decltype(other.begin()), bool&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies or moves the element at position <code>pos</code> from <code>other</code> into <code>this</code>. </p>
<p>Elements are only moved from <code>other</code> if <code>other</code> is an rvalue reference to non-const. If <code>other</code> is a reference to const <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>, then elements are copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set to copy or move the element from. </td></tr>
    <tr><td class="paramname">pos</td><td>- Iterator to the element to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::tuple whose first member is an iterator to the position in <code>this</code> where the element was inserted or the element that prevented the insertion, whose second member is an iterator (or <a class="el" href="structte_1_1AnySet_1_1const__iterator.html" title="Forward iterator type returned from const operations on AnySet instances. ">const_iterator</a>, if <code>other</code> is const) to the position in <code>other</code> of the element after the element at position <code>pos</code>, and whose third member is a bool indicating whether the copy/move occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No iterators are invalidated by this function.</dd>
<dd>
No element copy or move constructors are invoked by this function if <code>other</code> is a non-const rvalue. In that case, the element is moved by splicing an internal node object from <code>other</code> into <code>this</code>.</dd>
<dd>
If an exception is thrown due to a failure to allocate enough buckets for the new element, both <code>this</code> and <code>other</code> are unmodified. (conditional rollback semantics)</dd>
<dd>
If <code>other</code> is const and the value at position <code>pos</code> is an instance of a type that does not satisfy CopyConstructible, then this function throws a <a class="el" href="structte_1_1NoCopyConstructorError.html" title="Exception thrown when attempting to make copies of an AnyValue instance that contains an instance of ...">te::NoCopyConstructorError</a>. If this occurs, <code>this</code> and <code>other</code> are unmodified. (conditional rollback semantics) </dd></dl>

</div>
</div>
<a id="a81b4b02feab7c4ae295488622fd80485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b4b02feab7c4ae295488622fd80485">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the set with those of other. Does not invoke any move, copy, or swap operations on individual elements. Additionally exchanges the hash functions, comparison functions, and <a class="el" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998" title="Set the maximum possible number of buckets in the set. ">max_load_factor()</a>s of the sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- The set to exchange contents with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All iterators and references remain valid. '<a class="el" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00" title="Get a iterator to the first element in the set. ">begin()</a>' iterators do not change their allegiance. </dd></dl>

</div>
</div>
<a id="abc4a188e3477bb2fd20ed77832b2eca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4a188e3477bb2fd20ed77832b2eca3">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add copies of elements from <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- Set whose contents are to be added to the given set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>other</code> contains an element whose type does not satisfy CopyConstructible, this function throws a <a class="el" href="structte_1_1NoCopyConstructorError.html" title="Exception thrown when attempting to make copies of an AnyValue instance that contains an instance of ...">te::NoCopyConstructorError</a>.</dd>
<dd>
If an exception is thrown while this function is executing, <code>this</code> will be only partially updated. </dd></dl>

</div>
</div>
<a id="a42cffd4ef597d50514bd84509c4ddb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cffd4ef597d50514bd84509c4ddb9a">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="el" href="structte_1_1AnySet.html">te::AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves elements from <code>other</code> into the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- Set whose contents are to be moved to the given set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>No element copy or move constructors are invoked by this function. Elements are moved by splicing internal node objects from <code>other</code> into <code>this</code>.</dd>
<dd>
If an exception is thrown while this function is executing, <code>this</code> will be only partially updated and <code>other</code> will be missing any elements that added to <code>this</code>.</dd>
<dd>
No iterators are invalidated by this function, but iterators pointing into <code>other</code> may point to into <code>this</code> after the call to this function. Whether or not a particular iterator is past-the-end, and in which set it is past-the-end, may be changed.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function effectively erases any elements contained in <code>this</code> from <code>other</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a37c46f2275e85ea21dfd2919fe0981fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c46f2275e85ea21dfd2919fe0981fd">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the contents of two sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- Set whose contents are to be swapped with <code>right</code>. </td></tr>
    <tr><td class="paramname">right</td><td>- Set whose contents are to be swapped with <code>left</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if every element in <code>left</code> is contained in <code>right</code> and vice-versa, using operator== to test for element equality, otherwise true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If either set contains one or more objects of a type that does not satisfy the EqualityComparable concept, this function returns true. </dd></dl>

</div>
</div>
<a id="aa0195a9b300310dd1d599faec16f9c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0195a9b300310dd1d599faec16f9c8c">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the contents of two sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- Set whose contents are to be swapped with <code>right</code>. </td></tr>
    <tr><td class="paramname">right</td><td>- Set whose contents are to be swapped with <code>left</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every element in <code>left</code> is contained in <code>right</code> and vice-versa, using operator== to test for element equality, otherwise false.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If either set contains one or more objects of a type that does not satisfy the EqualityComparable concept, this function returns false. </dd></dl>

</div>
</div>
<a id="a074e520f91cc54b3df3d1278c9944367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074e520f91cc54b3df3d1278c9944367">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn = AnyHash, class KeyEqual = std::equal_to&lt;&gt;, class Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; HashFn, KeyEqual, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls left.swap(right). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- Set whose contents are to be swapped with <code>right</code>. </td></tr>
    <tr><td class="paramname">right</td><td>- Set whose contents are to be swapped with <code>left</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<div class="dynheader">
Inheritance diagram for te::AnySet&lt; HashFn, KeyEqual, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structte_1_1AnySet__inherit__graph.png" border="0" usemap="#te_1_1AnySet_3_01HashFn_00_01KeyEqual_00_01Allocator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="te_1_1AnySet_3_01HashFn_00_01KeyEqual_00_01Allocator_01_4_inherit__map" id="te_1_1AnySet_3_01HashFn_00_01KeyEqual_00_01Allocator_01_4_inherit__map">
<area shape="rect" id="node2" href="structte_1_1CompressedPair.html" title="te::CompressedPair\l\&lt; HashFn, KeyEqual \&gt;" alt="" coords="116,169,272,211"/>
<area shape="rect" id="node3" href="structte_1_1detail_1_1CompressedPairBase.html" title="te::detail::CompressedPair\lBase\&lt; HashFn \&gt;" alt="" coords="5,80,183,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for te::AnySet&lt; HashFn, KeyEqual, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structte_1_1AnySet__coll__graph.png" border="0" usemap="#te_1_1AnySet_3_01HashFn_00_01KeyEqual_00_01Allocator_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="te_1_1AnySet_3_01HashFn_00_01KeyEqual_00_01Allocator_01_4_coll__map" id="te_1_1AnySet_3_01HashFn_00_01KeyEqual_00_01Allocator_01_4_coll__map">
<area shape="rect" id="node2" href="structte_1_1CompressedPair.html" title="te::CompressedPair\l\&lt; HashFn, KeyEqual \&gt;" alt="" coords="116,169,272,211"/>
<area shape="rect" id="node3" href="structte_1_1detail_1_1CompressedPairBase.html" title="te::detail::CompressedPair\lBase\&lt; HashFn \&gt;" alt="" coords="5,80,183,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/tim/Projects/any-hash/include/anyset/<a class="el" href="AnySet_8h_source.html">AnySet.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
