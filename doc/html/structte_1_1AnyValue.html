<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>any-set-docs: te::AnyValue&lt; HashFn, Compare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">any-set-docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>te</b></li><li class="navelem"><a class="el" href="structte_1_1AnyValue.html">AnyValue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="structte_1_1AnyValue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">te::AnyValue&lt; HashFn, Compare &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__AnySet-Module.html">AnySet-Module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class HashFn, class Compare&gt;<br />
class te::AnyValue&lt; HashFn, Compare &gt;</h3>

<p>A <code>std::any</code> -like type that serves as the <code>value_type</code> for <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances.</p>
<p><a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instances are always dynamically-allocated and are typically owned by an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance. <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> has no user-visible constructors and is neither copy nor move-assignable.</p>
<p><a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instances can be spliced into and extracted from <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances whose <code>HashFn</code> and <code>KeyEqual</code> types are the same as <code>HashFn</code> and <code>Compare</code> respectively.</p>
<p>Following the conventions of <code>std::any</code>, the value contained in a particular <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance can be obtained using special 'cast' functions. The cast functions provided for <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> are <a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a>, <a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a>, and <a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a>. Additionally, non-cast-style accessor and query functions <a class="el" href="structte_1_1AnyValue.html#a0b97a869d111b68fabac62d4c10418c7" title="Check if any_v contains an object of type T. ">is()</a>, <a class="el" href="structte_1_1AnyValue.html#ad973f276438df3501add140e0d4cddd8" title="Get a reference to the contained object of type T. If the contained object is not an instance of type...">as()</a>, and <a class="el" href="structte_1_1AnyValue.html#aa7e03e69265821ef1f2fcfef7c635ae4" title="Get a pointer to the contained object of type T. If the contained object is not an instance of type T...">try_as()</a> are provided as well.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HashFn</td><td>- The type of the hash function object used in the corresponding <code><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>&lt;<code>HashFn</code>,</code> <code>Compare&gt;</code> instances. </td></tr>
    <tr><td class="paramname">Compare</td><td>- The type of the equality function object (<code>KeyEqual</code>) used in the corresponding <code><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>&lt;<code>HashFn</code>,</code> <code>Compare&gt;</code> instances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyHash.html" title="Generic hash function object. ">AnyHash</a> </dd></dl>
</div>
<p><code>#include &lt;<a class="el" href="AnyNode_8h_source.html">AnyNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a58bd4914f41742b8539efa3e782bb966"><td class="memItemLeft" align="right" valign="top"><a id="a58bd4914f41742b8539efa3e782bb966"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>self_type</b> = <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt;</td></tr>
<tr class="separator:a58bd4914f41742b8539efa3e782bb966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf75ad9bb7b836d60696f5952ce9465b"><td class="memItemLeft" align="right" valign="top"><a id="aaf75ad9bb7b836d60696f5952ce9465b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = HashFn</td></tr>
<tr class="separator:aaf75ad9bb7b836d60696f5952ce9465b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1059e6bc94aa2a4a1449f9d3f5d7c0b"><td class="memItemLeft" align="right" valign="top"><a id="ae1059e6bc94aa2a4a1449f9d3f5d7c0b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = Compare</td></tr>
<tr class="separator:ae1059e6bc94aa2a4a1449f9d3f5d7c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0616ef69001aacf15b6f3027363839f3"><td class="memItemLeft" align="right" valign="top"><a id="a0616ef69001aacf15b6f3027363839f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AnyValue</b> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;)=delete</td></tr>
<tr class="separator:a0616ef69001aacf15b6f3027363839f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d2971f8b277000c09adcbea107c67c"><td class="memItemLeft" align="right" valign="top"><a id="a51d2971f8b277000c09adcbea107c67c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AnyValue</b> (<a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a51d2971f8b277000c09adcbea107c67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b079f6ed8af088bd012c33e9d7b87e"><td class="memItemLeft" align="right" valign="top">virtual const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a88b079f6ed8af088bd012c33e9d7b87e">typeinfo</a> () const =0</td></tr>
<tr class="memdesc:a88b079f6ed8af088bd012c33e9d7b87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a std::type_info object that indicates the type of the contained object.  <a href="#a88b079f6ed8af088bd012c33e9d7b87e">More...</a><br /></td></tr>
<tr class="separator:a88b079f6ed8af088bd012c33e9d7b87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a50ee85dd2f51c8c2ddb59adeaf724a53"><td class="memItemLeft" align="right" valign="top">const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a50ee85dd2f51c8c2ddb59adeaf724a53">hash</a></td></tr>
<tr class="separator:a50ee85dd2f51c8c2ddb59adeaf724a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a06c0164c03474e50c6abaf1f757e2e0c"><td class="memItemLeft" align="right" valign="top"><a id="a06c0164c03474e50c6abaf1f757e2e0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AnyValue</b> (std::size_t hash_v)</td></tr>
<tr class="separator:a06c0164c03474e50c6abaf1f757e2e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da7aea9c6293d8587c43b0762f3bf3b"><td class="memItemLeft" align="right" valign="top"><a id="a4da7aea9c6293d8587c43b0762f3bf3b"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>compare_to</b> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;other, Compare comp) const =0</td></tr>
<tr class="separator:a4da7aea9c6293d8587c43b0762f3bf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9096b271aa5e4f2201481486c668a9"><td class="memItemLeft" align="right" valign="top"><a id="a6e9096b271aa5e4f2201481486c668a9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;other) const =0</td></tr>
<tr class="separator:a6e9096b271aa5e4f2201481486c668a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbedde9bc4e04f11de75470adbfcc0bc"><td class="memItemLeft" align="right" valign="top"><a id="afbedde9bc4e04f11de75470adbfcc0bc"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>not_equals</b> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;other) const =0</td></tr>
<tr class="separator:afbedde9bc4e04f11de75470adbfcc0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dee3846f267516c696d3b843a5bb009"><td class="memItemLeft" align="right" valign="top"><a id="a3dee3846f267516c696d3b843a5bb009"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (std::ostream &amp;os) const =0</td></tr>
<tr class="separator:a3dee3846f267516c696d3b843a5bb009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54faba1a4c8203fb357e95f77a746088"><td class="memItemLeft" align="right" valign="top"><a id="a54faba1a4c8203fb357e95f77a746088"></a>
virtual std::unique_ptr&lt; <a class="el" href="structte_1_1AnyValue.html">self_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> () const =0</td></tr>
<tr class="separator:a54faba1a4c8203fb357e95f77a746088"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a74ac20e3b7386e00bdf60d22cdfaced2"><td class="memTemplParams" colspan="2"><a id="a74ac20e3b7386e00bdf60d22cdfaced2"></a>
template&lt;class , class , class &gt; </td></tr>
<tr class="memitem:a74ac20e3b7386e00bdf60d22cdfaced2"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AnySet</b></td></tr>
<tr class="separator:a74ac20e3b7386e00bdf60d22cdfaced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02263f3be096a282fe5f4e25f2122a39"><td class="memItemLeft" align="right" valign="top"><a id="a02263f3be096a282fe5f4e25f2122a39"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::AnyList&lt; HashFn, Compare &gt;</b></td></tr>
<tr class="separator:a02263f3be096a282fe5f4e25f2122a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdbab3b6b1253377aa978eafdb57182"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a0fdbab3b6b1253377aa978eafdb57182">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;any_v)</td></tr>
<tr class="memdesc:a0fdbab3b6b1253377aa978eafdb57182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contained object to the given <code>std::ostream</code> using the stream insertion &lt;&lt; operator.  <a href="#a0fdbab3b6b1253377aa978eafdb57182">More...</a><br /></td></tr>
<tr class="separator:a0fdbab3b6b1253377aa978eafdb57182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison Operations</div></td></tr>
<tr class="memitem:a9feea4728645709078336cf47e78a0c3"><td class="memTemplParams" colspan="2"><a id="a9feea4728645709078336cf47e78a0c3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9feea4728645709078336cf47e78a0c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a9feea4728645709078336cf47e78a0c3">operator==</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;left, const T &amp;right)</td></tr>
<tr class="memdesc:a9feea4728645709078336cf47e78a0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the contained object in <code>left</code> is of type <code>T</code> and equal to <code>right</code>. <br /></td></tr>
<tr class="separator:a9feea4728645709078336cf47e78a0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ec4ddff48b307b7e0b1a569be57494"><td class="memTemplParams" colspan="2"><a id="a25ec4ddff48b307b7e0b1a569be57494"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a25ec4ddff48b307b7e0b1a569be57494"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a25ec4ddff48b307b7e0b1a569be57494">operator==</a> (const T &amp;left, const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;right)</td></tr>
<tr class="memdesc:a25ec4ddff48b307b7e0b1a569be57494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the contained object in <code>right</code> is of type <code>T</code> and equal to <code>left</code>. <br /></td></tr>
<tr class="separator:a25ec4ddff48b307b7e0b1a569be57494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac661f35d597e51ab0e72f618d5eb0353"><td class="memTemplParams" colspan="2"><a id="ac661f35d597e51ab0e72f618d5eb0353"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac661f35d597e51ab0e72f618d5eb0353"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#ac661f35d597e51ab0e72f618d5eb0353">operator!=</a> (const T &amp;left, const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;right)</td></tr>
<tr class="memdesc:ac661f35d597e51ab0e72f618d5eb0353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the contained object in <code>right</code> is not of type <code>T</code> or not equal to <code>left</code>. <br /></td></tr>
<tr class="separator:ac661f35d597e51ab0e72f618d5eb0353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bf9e5a14991f5fe8cd87cbba5e6496"><td class="memTemplParams" colspan="2"><a id="a85bf9e5a14991f5fe8cd87cbba5e6496"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a85bf9e5a14991f5fe8cd87cbba5e6496"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a85bf9e5a14991f5fe8cd87cbba5e6496">operator!=</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;left, const T &amp;right)</td></tr>
<tr class="memdesc:a85bf9e5a14991f5fe8cd87cbba5e6496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the contained object in <code>left</code> is not of type <code>T</code> or not equal to <code>right</code>. <br /></td></tr>
<tr class="separator:a85bf9e5a14991f5fe8cd87cbba5e6496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5e480ad283ee5ac6c03e75b53e1cce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a9c5e480ad283ee5ac6c03e75b53e1cce">operator==</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;left, const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;right)</td></tr>
<tr class="memdesc:a9c5e480ad283ee5ac6c03e75b53e1cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the contained objects in <code>left</code> and <code>right</code> are of the same equality-comparable type, and subsequently whether the contained, same-type objects compare equal using operator==.  <a href="#a9c5e480ad283ee5ac6c03e75b53e1cce">More...</a><br /></td></tr>
<tr class="separator:a9c5e480ad283ee5ac6c03e75b53e1cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb1dc99930cf4e99eac4b3c30548607"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a3cb1dc99930cf4e99eac4b3c30548607">operator!=</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;left, const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;right)</td></tr>
<tr class="memdesc:a3cb1dc99930cf4e99eac4b3c30548607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the contained objects in <code>left</code> and <code>right</code> are of different types, or whether the contained same-type objects compare not-equal using operator!=.  <a href="#a3cb1dc99930cf4e99eac4b3c30548607">More...</a><br /></td></tr>
<tr class="separator:a3cb1dc99930cf4e99eac4b3c30548607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd46a03c8ec292dfa93f553067d5a353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#abd46a03c8ec292dfa93f553067d5a353">compare</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;left, const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;right, Compare comp)</td></tr>
<tr class="memdesc:abd46a03c8ec292dfa93f553067d5a353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the contained objects in <code>left</code> and <code>right</code> are of the same type, and subsequently whether the contained same-type objects compare equal using the provided instance of the <code>Compare</code> comparison function object.  <a href="#abd46a03c8ec292dfa93f553067d5a353">More...</a><br /></td></tr>
<tr class="separator:abd46a03c8ec292dfa93f553067d5a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fa80de1b44e443348e8c3b876dd4d8"><td class="memTemplParams" colspan="2">template&lt;class T , class Comp  = Compare, class  = std::enable_if_t&lt;not std::is_same_v&lt;T, self_type&gt;&gt;&gt; </td></tr>
<tr class="memitem:a45fa80de1b44e443348e8c3b876dd4d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a45fa80de1b44e443348e8c3b876dd4d8">compare</a> (const T &amp;left, const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;right, Comp comp)</td></tr>
<tr class="memdesc:a45fa80de1b44e443348e8c3b876dd4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the contained object in <code>right</code> is of type <code>T</code> and subsequently whether the contained object compares equal to <code>left</code> using the provided instance of the <code>Comp</code> comparison function object.  <a href="#a45fa80de1b44e443348e8c3b876dd4d8">More...</a><br /></td></tr>
<tr class="separator:a45fa80de1b44e443348e8c3b876dd4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d99868fadf563d33d5c2188f8e82be"><td class="memTemplParams" colspan="2">template&lt;class T , class Comp  = Compare, class  = std::enable_if_t&lt;not std::is_same_v&lt;T, self_type&gt;&gt;&gt; </td></tr>
<tr class="memitem:a24d99868fadf563d33d5c2188f8e82be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a24d99868fadf563d33d5c2188f8e82be">compare</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> &amp;left, const T &amp;right, Comp comp)</td></tr>
<tr class="memdesc:a24d99868fadf563d33d5c2188f8e82be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the contained object in <code>left</code> is of type <code>T</code> and subsequently whether the contained object compares equal to <code>right</code> using the provided instance of the <code>Comp</code> comparison function object.  <a href="#a24d99868fadf563d33d5c2188f8e82be">More...</a><br /></td></tr>
<tr class="separator:a24d99868fadf563d33d5c2188f8e82be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a0b97a869d111b68fabac62d4c10418c7"><td class="memTemplParams" colspan="2">template&lt;class T , class H , class C &gt; </td></tr>
<tr class="memitem:a0b97a869d111b68fabac62d4c10418c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a0b97a869d111b68fabac62d4c10418c7">is</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;any_v)</td></tr>
<tr class="memdesc:a0b97a869d111b68fabac62d4c10418c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>any_v</code> contains an object of type T.  <a href="#a0b97a869d111b68fabac62d4c10418c7">More...</a><br /></td></tr>
<tr class="separator:a0b97a869d111b68fabac62d4c10418c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117089927a63d45e7f74465d6c42f043"><td class="memTemplParams" colspan="2">template&lt;class T , class H , class C , class ... Args&gt; </td></tr>
<tr class="memitem:a117089927a63d45e7f74465d6c42f043"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a117089927a63d45e7f74465d6c42f043">make_any_value</a> (H hasher, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a117089927a63d45e7f74465d6c42f043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a std::unique_ptr&lt;AnyValue&lt;H, C&gt;&gt; suitable for splicing into an <code><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>&lt;<code>H</code>,</code> <code>C&gt;</code> instance.  <a href="#a117089927a63d45e7f74465d6c42f043">More...</a><br /></td></tr>
<tr class="separator:a117089927a63d45e7f74465d6c42f043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda959024b77931e4e9b5d190b74cae5"><td class="memTemplParams" colspan="2"><a id="adda959024b77931e4e9b5d190b74cae5"></a>
template&lt;class H , class C &gt; </td></tr>
<tr class="memitem:adda959024b77931e4e9b5d190b74cae5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#adda959024b77931e4e9b5d190b74cae5">compute_hash</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;any_v)</td></tr>
<tr class="memdesc:adda959024b77931e4e9b5d190b74cae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads <a class="el" href="structte_1_1AnyValue.html#adda959024b77931e4e9b5d190b74cae5" title="Overloads compute_hash() for AnyValue. ">compute_hash()</a> for <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>. <br /></td></tr>
<tr class="separator:adda959024b77931e4e9b5d190b74cae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Casts and Accessors</div></td></tr>
<tr class="memitem:af4d90407920686c0d304f48e6661b8ea"><td class="memTemplParams" colspan="2">template&lt;class To , class H , class C &gt; </td></tr>
<tr class="memitem:af4d90407920686c0d304f48e6661b8ea"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea">polymorphic_cast</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;any_v)</td></tr>
<tr class="memdesc:af4d90407920686c0d304f48e6661b8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the contained object through a reference to dynamic type <code>To</code>.  <a href="#af4d90407920686c0d304f48e6661b8ea">More...</a><br /></td></tr>
<tr class="separator:af4d90407920686c0d304f48e6661b8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7ccc18aff60565ed470cdde507ea2f"><td class="memTemplParams" colspan="2">template&lt;class To , class H , class C &gt; </td></tr>
<tr class="memitem:a5e7ccc18aff60565ed470cdde507ea2f"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a5e7ccc18aff60565ed470cdde507ea2f">polymorphic_cast</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; *any_v)</td></tr>
<tr class="memdesc:a5e7ccc18aff60565ed470cdde507ea2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the contained object through a pointer to dynamic type <code>To</code>.  <a href="#a5e7ccc18aff60565ed470cdde507ea2f">More...</a><br /></td></tr>
<tr class="separator:a5e7ccc18aff60565ed470cdde507ea2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab870f1e471f93b1e6a281471ffa17363"><td class="memTemplParams" colspan="2">template&lt;class To , class H , class C &gt; </td></tr>
<tr class="memitem:ab870f1e471f93b1e6a281471ffa17363"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363">exact_cast</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;any_v)</td></tr>
<tr class="memdesc:ab870f1e471f93b1e6a281471ffa17363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the contained object.  <a href="#ab870f1e471f93b1e6a281471ffa17363">More...</a><br /></td></tr>
<tr class="separator:ab870f1e471f93b1e6a281471ffa17363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf81819142bde5869584d94bc029c332"><td class="memTemplParams" colspan="2">template&lt;class To , class H , class C &gt; </td></tr>
<tr class="memitem:abf81819142bde5869584d94bc029c332"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#abf81819142bde5869584d94bc029c332">exact_cast</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; *any_v)</td></tr>
<tr class="memdesc:abf81819142bde5869584d94bc029c332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the contained object.  <a href="#abf81819142bde5869584d94bc029c332">More...</a><br /></td></tr>
<tr class="separator:abf81819142bde5869584d94bc029c332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8862ffbba80ea1a12cc2117348c4efe8"><td class="memTemplParams" colspan="2">template&lt;class To , class H , class C &gt; </td></tr>
<tr class="memitem:a8862ffbba80ea1a12cc2117348c4efe8"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8">unsafe_cast</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;any_v)</td></tr>
<tr class="memdesc:a8862ffbba80ea1a12cc2117348c4efe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the contained object without dynamic type checking.  <a href="#a8862ffbba80ea1a12cc2117348c4efe8">More...</a><br /></td></tr>
<tr class="separator:a8862ffbba80ea1a12cc2117348c4efe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e03e69265821ef1f2fcfef7c635ae4"><td class="memTemplParams" colspan="2">template&lt;class T , class H , class C &gt; </td></tr>
<tr class="memitem:aa7e03e69265821ef1f2fcfef7c635ae4"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#aa7e03e69265821ef1f2fcfef7c635ae4">try_as</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;any_v)</td></tr>
<tr class="memdesc:aa7e03e69265821ef1f2fcfef7c635ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the contained object of type T. If the contained object is not an instance of type T, returns nullptr.  <a href="#aa7e03e69265821ef1f2fcfef7c635ae4">More...</a><br /></td></tr>
<tr class="separator:aa7e03e69265821ef1f2fcfef7c635ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad973f276438df3501add140e0d4cddd8"><td class="memTemplParams" colspan="2">template&lt;class T , class H , class C &gt; </td></tr>
<tr class="memitem:ad973f276438df3501add140e0d4cddd8"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html#ad973f276438df3501add140e0d4cddd8">as</a> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;self)</td></tr>
<tr class="memdesc:ad973f276438df3501add140e0d4cddd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the contained object of type T. If the contained object is not an instance of type T, throws a std::bad_cast.  <a href="#ad973f276438df3501add140e0d4cddd8">More...</a><br /></td></tr>
<tr class="separator:ad973f276438df3501add140e0d4cddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88b079f6ed8af088bd012c33e9d7b87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b079f6ed8af088bd012c33e9d7b87e">&#9670;&nbsp;</a></span>typeinfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn, class Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::type_info&amp; <a class="el" href="structte_1_1AnyValue.html">te::AnyValue</a>&lt; HashFn, Compare &gt;::typeinfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to a std::type_info object that indicates the type of the contained object. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::type_info object that indicates the type of the contained object. </dd></dl>

<p>Implemented in <a class="el" href="structte_1_1detail_1_1TypedValue.html#a6df86b446b11958f2bb15acb19674efe">te::detail::TypedValue&lt; Value, HashFn, Compare &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad973f276438df3501add140e0d4cddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad973f276438df3501add140e0d4cddd8">&#9670;&nbsp;</a></span>as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class H , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the contained object of type T. If the contained object is not an instance of type T, throws a std::bad_cast. </p>
<p>This function works by attempting an <a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a> followed by, if the <a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a> failed, a <a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a>. The <a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a> is only attempted if <code>T</code> is a non-final class type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- The <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance whose contained object is to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference of type <code>const T&amp;</code> to the contained object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_cast</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnyValue.html#aa7e03e69265821ef1f2fcfef7c635ae4" title="Get a pointer to the contained object of type T. If the contained object is not an instance of type T...">try_as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html">AnyValue</a> </dd></dl>

</div>
</div>
<a id="abd46a03c8ec292dfa93f553067d5a353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd46a03c8ec292dfa93f553067d5a353">&#9670;&nbsp;</a></span>compare <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn, class Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the contained objects in <code>left</code> and <code>right</code> are of the same type, and subsequently whether the contained same-type objects compare equal using the provided instance of the <code>Compare</code> comparison function object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- An instance of <code><a class="el" href="structte_1_1AnyValue.html">te::AnyValue</a>&lt;<code>HashFn</code>,</code> <code>Compare&gt;</code>. </td></tr>
    <tr><td class="paramname">right</td><td>- An instance of <code><a class="el" href="structte_1_1AnyValue.html">te::AnyValue</a>&lt;<code>HashFn</code>,</code> <code>Compare&gt;</code>. </td></tr>
    <tr><td class="paramname">comp</td><td>- The instance of <code>Compare</code> to use for comparing the contained objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contained types are identical and compare equal when <code>comp</code> is invoked with the contained objects. </dd></dl>

</div>
</div>
<a id="a45fa80de1b44e443348e8c3b876dd4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fa80de1b44e443348e8c3b876dd4d8">&#9670;&nbsp;</a></span>compare <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn, class Compare&gt; </div>
<div class="memtemplate">
template&lt;class T , class Comp  = Compare, class  = std::enable_if_t&lt;not std::is_same_v&lt;T, self_type&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool compare </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the contained object in <code>right</code> is of type <code>T</code> and subsequently whether the contained object compares equal to <code>left</code> using the provided instance of the <code>Comp</code> comparison function object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- An instance of type <code>T</code>. </td></tr>
    <tr><td class="paramname">right</td><td>- An instance of <code><a class="el" href="structte_1_1AnyValue.html">te::AnyValue</a>&lt;<code>HashFn</code>,</code> <code>Compare&gt;</code>. </td></tr>
    <tr><td class="paramname">comp</td><td>- An instance of an arbitrary comparison function type <code>Comp</code> to use for comparing the contained objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contained types are identical and compare equal when <code>comp</code> is invoked with the contained objects. </dd></dl>

</div>
</div>
<a id="a24d99868fadf563d33d5c2188f8e82be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d99868fadf563d33d5c2188f8e82be">&#9670;&nbsp;</a></span>compare <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn, class Compare&gt; </div>
<div class="memtemplate">
template&lt;class T , class Comp  = Compare, class  = std::enable_if_t&lt;not std::is_same_v&lt;T, self_type&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the contained object in <code>left</code> is of type <code>T</code> and subsequently whether the contained object compares equal to <code>right</code> using the provided instance of the <code>Comp</code> comparison function object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- An instance of <code><a class="el" href="structte_1_1AnyValue.html">te::AnyValue</a>&lt;<code>HashFn</code>,</code> <code>Compare&gt;</code>. </td></tr>
    <tr><td class="paramname">right</td><td>- An instance of type <code>T</code>. </td></tr>
    <tr><td class="paramname">comp</td><td>- An instance of an arbitrary comparison function type <code>Comp</code> to use for comparing the contained objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contained types are identical and compare equal when <code>comp</code> is invoked with the contained objects. </dd></dl>

</div>
</div>
<a id="ab870f1e471f93b1e6a281471ffa17363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab870f1e471f93b1e6a281471ffa17363">&#9670;&nbsp;</a></span>exact_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class H , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To exact_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>any_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the contained object. </p>
<p>If the type of contained object is not the same as the requested type (after stripping off references and cv qualifiers, i.e. std::decay), throws a <code>std::bad_cast</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>- The type to access the contained object as. May be a reference or value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- The <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance whose contained object is to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to (or copy of, if <code>To</code> is a non-reference type) the contained object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_cast</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#aa7e03e69265821ef1f2fcfef7c635ae4" title="Get a pointer to the contained object of type T. If the contained object is not an instance of type T...">try_as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#ad973f276438df3501add140e0d4cddd8" title="Get a reference to the contained object of type T. If the contained object is not an instance of type...">as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html">AnyValue</a> </dd></dl>

</div>
</div>
<a id="abf81819142bde5869584d94bc029c332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf81819142bde5869584d94bc029c332">&#9670;&nbsp;</a></span>exact_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class H , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To exact_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; *&#160;</td>
          <td class="paramname"><em>any_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the contained object. </p>
<p>If the type of contained object is not the same as the requested type (after stripping off top-level pointer and then cv qualifiers), returns null.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>- The type to access the contained object as. Must be a pointer to the expected type of the contained object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- The <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance whose contained object is to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the contained object of type T.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#aa7e03e69265821ef1f2fcfef7c635ae4" title="Get a pointer to the contained object of type T. If the contained object is not an instance of type T...">try_as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#ad973f276438df3501add140e0d4cddd8" title="Get a reference to the contained object of type T. If the contained object is not an instance of type...">as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html">AnyValue</a> </dd></dl>

</div>
</div>
<a id="a0b97a869d111b68fabac62d4c10418c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b97a869d111b68fabac62d4c10418c7">&#9670;&nbsp;</a></span>is()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class H , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>any_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>any_v</code> contains an object of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- The <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance whose contained type is to be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance contains an object of type T, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnyValue.html">AnyValue</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a> </dd></dl>

</div>
</div>
<a id="a117089927a63d45e7f74465d6c42f043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117089927a63d45e7f74465d6c42f043">&#9670;&nbsp;</a></span>make_any_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class H , class C , class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &gt; make_any_value </td>
          <td>(</td>
          <td class="paramtype">H&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a std::unique_ptr&lt;AnyValue&lt;H, C&gt;&gt; suitable for splicing into an <code><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>&lt;<code>H</code>,</code> <code>C&gt;</code> instance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- The type of the contained value. </td></tr>
    <tr><td class="paramname">H</td><td>- The type of hash function object used by <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances that </td></tr>
    <tr><td class="paramname">C</td><td>- The type of the contained value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hasher</td><td>- The instance of <code>H</code> to use to compute the hash of contained <code>T</code> object after it is constructed in the <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>. </td></tr>
    <tr><td class="paramname">args</td><td>- Arguments to forward to <code>T's</code> constructor.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cb1dc99930cf4e99eac4b3c30548607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb1dc99930cf4e99eac4b3c30548607">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn, class Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the contained objects in <code>left</code> and <code>right</code> are of different types, or whether the contained same-type objects compare not-equal using operator!=. </p>
<dl class="section note"><dt>Note</dt><dd>If either of the contained objects are of non-inequality-comparable types, this function returns <code>true</code>. This is the case even if the contained objects are of the same, empty type.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contained types are not identical, if the contained types are not inequality-comparable, or if the contained same-type objects compare not-equal via operator!=. </dd></dl>

</div>
</div>
<a id="a0fdbab3b6b1253377aa978eafdb57182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdbab3b6b1253377aa978eafdb57182">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn, class Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>any_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the contained object to the given <code>std::ostream</code> using the stream insertion &lt;&lt; operator. </p>
<dl class="section note"><dt>Note</dt><dd>If the contained object is of a type that is not streamable (has no <code>operator&lt;&lt;</code>(<code>std::ostream</code>, <code>const</code> <code>T&amp;</code>) overload), writes a string of the form "AnyValue(typeid.name='&lt;typeid(T).name()&gt;', hash=&lt;hash code&gt;)". </dd></dl>

</div>
</div>
<a id="a9c5e480ad283ee5ac6c03e75b53e1cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5e480ad283ee5ac6c03e75b53e1cce">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn, class Compare&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; HashFn, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the contained objects in <code>left</code> and <code>right</code> are of the same equality-comparable type, and subsequently whether the contained, same-type objects compare equal using operator==. </p>
<dl class="section note"><dt>Note</dt><dd>If either of the contained objects are of non-equality-comparable types, this function returns <code>false</code>. This is the case even if the contained objects are of the same, empty type.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contained types are identical, the contained type is equality-comparable, and if the contained same-type objects compare equal via operator==. </dd></dl>

</div>
</div>
<a id="af4d90407920686c0d304f48e6661b8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d90407920686c0d304f48e6661b8ea">&#9670;&nbsp;</a></span>polymorphic_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class H , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To polymorphic_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>any_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the contained object through a reference to dynamic type <code>To</code>. </p>
<p>Unlike <code><a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a></code> or <code><a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a></code>, <code><a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a></code> can access the <code><a class="el" href="structte_1_1AnyValue.html">AnyValue</a></code> instance's contained object through a reference to a base type of the contained object. For example, an <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance which contains an object of type <code>std::runtime_error</code> could be <a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a>'d to <code>const std::exception&amp;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Neither the type of the contained object nor target type of the cast need be of polymorphic type for this cast to work. <a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a> can cast through non-polymorphic inheritence heirarchies.</dd></dl>
<p>If the contained object is of non-class type, throws a <code>std::bad_cast</code>.</p>
<p>If the contained object is an instance of a final class type, throws a <code>std::bad_cast</code>, even if the contained object is an instance of <code>To</code>.</p>
<p>If <code>To</code> is a reference to non-class or final class type, the cast fails to compile.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>- The type to cast to. Should take the form <code>const T&amp;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- The <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance whose contained object is being accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the contained object of the requested type.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_cast</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#aa7e03e69265821ef1f2fcfef7c635ae4" title="Get a pointer to the contained object of type T. If the contained object is not an instance of type T...">try_as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#ad973f276438df3501add140e0d4cddd8" title="Get a reference to the contained object of type T. If the contained object is not an instance of type...">as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html">AnyValue</a> </dd></dl>

</div>
</div>
<a id="a5e7ccc18aff60565ed470cdde507ea2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7ccc18aff60565ed470cdde507ea2f">&#9670;&nbsp;</a></span>polymorphic_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class H , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To polymorphic_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; *&#160;</td>
          <td class="paramname"><em>any_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the contained object through a pointer to dynamic type <code>To</code>. </p>
<p>Unlike <code><a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a></code> or <code><a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a></code>, <code><a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a></code> can access the <code><a class="el" href="structte_1_1AnyValue.html">AnyValue</a></code> instance's contained object through a (possibly polymorphic) pointer to a base type of the contained object. For example, an <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance which contains an object of type <code>std::runtime_error</code> could be <a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a>'d to <code>const std::exception*</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Neither the type of the contained object nor target type of the cast need be of polymorphic type for this cast to work. <a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a> can cast through non-polymorphic inheritence heirarchies.</dd></dl>
<p>If the contained object is of non-class type, returns <code>nullptr</code>.</p>
<p>If the contained object is an instance of a final class type, returns <code>nullptr</code>, even if the contained object is an instance of <code>To</code>.</p>
<p>If <code>To</code> is a pointer to non-class or final class type, the cast fails to compile.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>- The type to cast to. Should take the form <code>const T*</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- The <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance whose contained object is being accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the contained object of the requested type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#aa7e03e69265821ef1f2fcfef7c635ae4" title="Get a pointer to the contained object of type T. If the contained object is not an instance of type T...">try_as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#ad973f276438df3501add140e0d4cddd8" title="Get a reference to the contained object of type T. If the contained object is not an instance of type...">as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html">AnyValue</a> </dd></dl>

</div>
</div>
<a id="aa7e03e69265821ef1f2fcfef7c635ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e03e69265821ef1f2fcfef7c635ae4">&#9670;&nbsp;</a></span>try_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class H , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * try_as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>any_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the contained object of type T. If the contained object is not an instance of type T, returns nullptr. </p>
<p>This function works by attempting to return <code>te::exact_cast&lt;const T*&gt;(&amp;self)</code> followed by a <code>te::polymorphic_cast&lt;const T*&gt;(&amp;self)</code> if the <a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a> failed. The <a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a> is only attempted if <code>T</code> is a non-final class type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- The <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance whose contained object is to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer of type <code>const T*</code> to the contained object if the contained object has type <code>T</code>, otherwise null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#a8862ffbba80ea1a12cc2117348c4efe8" title="Access the contained object without dynamic type checking. ">unsafe_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#ad973f276438df3501add140e0d4cddd8" title="Get a reference to the contained object of type T. If the contained object is not an instance of type...">as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html">AnyValue</a> </dd></dl>

</div>
</div>
<a id="a8862ffbba80ea1a12cc2117348c4efe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8862ffbba80ea1a12cc2117348c4efe8">&#9670;&nbsp;</a></span>unsafe_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class H , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To unsafe_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>any_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the contained object without dynamic type checking. </p>
<p>If the type of contained object is not the same as the requested type (after stripping off top-level reference and then cv qualifiers, i.e. std::decay), then the behavior is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>- The type to access the contained object as. Must be the type of the contained object or const reference thereto.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any_v</td><td>- The <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance whose contained object is to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the contained object of type T.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structte_1_1AnyValue.html#ab870f1e471f93b1e6a281471ffa17363" title="Access the contained object. ">exact_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#af4d90407920686c0d304f48e6661b8ea" title="Access the contained object through a reference to dynamic type To. ">polymorphic_cast()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#aa7e03e69265821ef1f2fcfef7c635ae4" title="Get a pointer to the contained object of type T. If the contained object is not an instance of type T...">try_as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html#ad973f276438df3501add140e0d4cddd8" title="Get a reference to the contained object of type T. If the contained object is not an instance of type...">as()</a> </dd>
<dd>
<a class="el" href="structte_1_1AnyValue.html">AnyValue</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a50ee85dd2f51c8c2ddb59adeaf724a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ee85dd2f51c8c2ddb59adeaf724a53">&#9670;&nbsp;</a></span>hash</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashFn, class Compare&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::size_t <a class="el" href="structte_1_1AnyValue.html">te::AnyValue</a>&lt; HashFn, Compare &gt;::hash</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The hash code obtained by invoking an instance of <code>HashFn</code> on the contained object. </p>

</div>
</div>
<div class="dynheader">
Inheritance diagram for te::AnyValue&lt; HashFn, Compare &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structte_1_1AnyValue__inherit__graph.png" border="0" usemap="#te_1_1AnyValue_3_01HashFn_00_01Compare_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="te_1_1AnyValue_3_01HashFn_00_01Compare_01_4_inherit__map" id="te_1_1AnyValue_3_01HashFn_00_01Compare_01_4_inherit__map">
<area shape="rect" id="node2" href="structte_1_1detail_1_1TypedValue.html" title="This class is an implementation detail and is not part of the public interface of AnyValue..." alt="" coords="26,95,179,136"/>
<area shape="rect" id="node3" href="structte_1_1detail_1_1AnyValueLink.html" title="This class is an implementation detail and is not part of the public interface of AnyValue..." alt="" coords="5,184,200,225"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/tim/Projects/any-hash/include/anyset/<a class="el" href="AnyNode_8h_source.html">AnyNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
