<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>any-set-docs: /home/tim/Projects/any-hash/include/anyset/AnySet.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">any-set-docs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_b547616e80677ed7cb4dbf77a3d52521.html">anyset</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">AnySet.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#ifndef ANY_SET_H</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#define ANY_SET_H</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="preprocessor">#include &lt;cstddef&gt;</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#include &quot;AnyList.h&quot;</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &lt;numeric&gt;</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &lt;bitset&gt;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#include &quot;AnyHash.h&quot;</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#include &quot;CompressedPair.h&quot;</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacete.html">te</a> {</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="keyword">namespace </span>detail {</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><a name="l00033"></a><span class="lineno"><a class="line" href="structte_1_1detail_1_1is__iterator.html">   33</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structte_1_1detail_1_1is__iterator.html">is_iterator</a></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">false</span>;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;};</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a name="l00039"></a><span class="lineno"><a class="line" href="structte_1_1detail_1_1is__iterator_3_01T_00_01std_1_1enable__if__t_3_9std_1_1is__same__v_3_01typcd54763bb77138f8b79c9edf4c46fbe5.html">   39</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structte_1_1detail_1_1is__iterator.html">is_iterator</a>&lt;T, std::enable_if_t&lt;!std::is_same_v&lt;typename std::iterator_traits&lt;T&gt;::value_type, void&gt;&gt;&gt;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;{</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;};</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="keyword">inline</span> constexpr <span class="keyword">const</span> <span class="keywordtype">bool</span> is_iterator_v = <a class="code" href="structte_1_1detail_1_1is__iterator.html">is_iterator&lt;T&gt;::value</a>;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;} <span class="comment">/* namespace detail */</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="keyword">template</span> &lt;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keyword">class </span>HashFn = <a class="code" href="structte_1_1AnyHash.html">AnyHash</a>,</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keyword">class </span>KeyEqual = std::equal_to&lt;&gt;,</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keyword">class </span>Allocator = std::allocator&lt;AnyValue&lt;HashFn, KeyEqual&gt;&gt;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;&gt;</div><div class="line"><a name="l00089"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html">   89</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structte_1_1AnySet.html">AnySet</a>:</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keyword">private</span> <a class="code" href="structte_1_1CompressedPair.html">CompressedPair</a>&lt;HashFn, KeyEqual&gt;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;{</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html">self_type</a> = <a class="code" href="structte_1_1AnySet.html">AnySet&lt;HashFn, KeyEqual, Allocator&gt;</a>;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keyword">using</span> <a class="code" href="classte_1_1detail_1_1AnyList.html">list_type</a> = <a class="code" href="classte_1_1detail_1_1AnyList.html">detail::AnyList&lt;HashFn, KeyEqual&gt;</a>;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keyword">using</span> list_iterator = <span class="keyword">typename</span> list_type::iterator;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keyword">using</span> const_list_iterator = <span class="keyword">typename</span> list_type::const_iterator;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00110"></a><span class="lineno"><a class="line" href="structte_1_1AnySet_1_1iterator.html">  110</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>:</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="keyword">public</span> list_iterator</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    {</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="keyword">using</span> value_type        = <span class="keyword">typename</span> <a class="code" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">AnySet::value_type</a>;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <span class="keyword">using</span> reference         = <span class="keyword">typename</span> <a class="code" href="structte_1_1AnySet.html#a0ebc7157c6f105886de8e40fc0c3d9ad">AnySet::reference</a>;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keyword">using</span> pointer           = <span class="keyword">typename</span> <a class="code" href="structte_1_1AnySet.html#a572260b03bc8d5d23eb71f0c0e6193d0">AnySet::pointer</a>;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keyword">using</span> difference_type   = <span class="keyword">typename</span> <a class="code" href="structte_1_1AnySet.html#a9c6c0e28fee9b4a3f8ea81e2bd55e28b">AnySet::difference_type</a>;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="keyword">using</span> iterator_category = std::forward_iterator_tag;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keyword">using</span> list_iterator::list_iterator;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keyword">using</span> list_iterator::operator=;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>(<span class="keyword">const</span> list_iterator&amp; it):</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            list_iterator(it)</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            </div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        }</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        </div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> to_non_const()<span class="keyword"> const</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="keyword">        </span>{ </div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>(</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                static_cast&lt;const list_iterator&amp;&gt;(*this).to_non_const()</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            ); </div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        }</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="structte_1_1AnySet.html">AnySet</a>;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    };</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno"><a class="line" href="structte_1_1AnySet_1_1const__iterator.html">  149</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>:</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keyword">public</span> const_list_iterator</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keyword">using</span> value_type        = <span class="keyword">typename</span> <a class="code" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">AnySet::value_type</a>;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keyword">using</span> reference         = <span class="keyword">typename</span> <a class="code" href="structte_1_1AnySet.html#abce3c18f84fe9f996434290602994109">AnySet::const_reference</a>;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keyword">using</span> pointer           = <span class="keyword">typename</span> <a class="code" href="structte_1_1AnySet.html#a70003fbdad1535a8ee15fba0b13d670b">AnySet::const_pointer</a>;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        <span class="keyword">using</span> difference_type   = <span class="keyword">typename</span> <a class="code" href="structte_1_1AnySet.html#a9c6c0e28fee9b4a3f8ea81e2bd55e28b">AnySet::difference_type</a>;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keyword">using</span> iterator_category = std::forward_iterator_tag;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>(<span class="keyword">const</span> const_list_iterator&amp; it):</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            const_list_iterator(it)</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        {</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            </div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>(<span class="keyword">const</span> list_iterator&amp; it):</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            const_list_iterator(it)</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        {</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            </div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        }</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&amp; other)</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        {</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>(other);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keyword">using</span> const_list_iterator::const_list_iterator;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <span class="keyword">using</span> const_list_iterator::operator=;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> to_non_const()<span class="keyword"> const</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="keyword">        </span>{ </div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>(</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                static_cast&lt;const const_list_iterator&amp;&gt;(*this).to_non_const()</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            ); </div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        }</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="structte_1_1AnySet.html">AnySet</a>;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    };</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="keyword">using</span> table_allocator = <span class="keyword">typename</span> std::allocator_traits&lt;Allocator&gt;::template rebind_alloc&lt;iterator&gt;;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keyword">using</span> vector_type = std::vector&lt;iterator, table_allocator&gt;;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1CompressedPair.html">pair_type</a> = <a class="code" href="structte_1_1CompressedPair.html">CompressedPair&lt;HashFn, KeyEqual&gt;</a>;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    <span class="keyword">using</span> vector_iterator = <span class="keyword">typename</span> vector_type::iterator;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="keyword">using</span> const_vector_iterator = <span class="keyword">typename</span> vector_type::const_iterator;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="keyword">struct </span>KeyInfo {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keyword">const</span> T&amp; value;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keyword">const</span> std::size_t hash;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        std::size_t bucket;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    };</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00204"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">  204</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a> = <a class="code" href="structte_1_1AnyValue.html">AnyValue&lt;HashFn, KeyEqual&gt;</a>;</div><div class="line"><a name="l00206"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">  206</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> = <span class="keyword">typename</span> vector_type::size_type;</div><div class="line"><a name="l00208"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a9c6c0e28fee9b4a3f8ea81e2bd55e28b">  208</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html#a9c6c0e28fee9b4a3f8ea81e2bd55e28b">difference_type</a> = <span class="keyword">typename</span> vector_type::difference_type;</div><div class="line"><a name="l00210"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a8ad77e4efb4d9e761042f816af59a4a4">  210</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html#a8ad77e4efb4d9e761042f816af59a4a4">key_equal</a> = KeyEqual;</div><div class="line"><a name="l00212"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a8d67e0b2dc842b7f6b858b974b694e4f">  212</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html#a8d67e0b2dc842b7f6b858b974b694e4f">hasher</a> = HashFn;</div><div class="line"><a name="l00214"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a034124e5f924602e12198f57f8dc18ae">  214</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html#a034124e5f924602e12198f57f8dc18ae">allocator_type</a> = Allocator;</div><div class="line"><a name="l00216"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a4ee089bf8502c8d062ebb0b493111fc1">  216</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnyValue.html">key_type</a> = <a class="code" href="structte_1_1AnyValue.html">value_type</a>;</div><div class="line"><a name="l00218"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a0ebc7157c6f105886de8e40fc0c3d9ad">  218</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnyValue.html">reference</a> = <a class="code" href="structte_1_1AnyValue.html">value_type</a>&amp;;</div><div class="line"><a name="l00220"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#abce3c18f84fe9f996434290602994109">  220</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnyValue.html">const_reference</a> = <span class="keyword">const</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>&amp;;</div><div class="line"><a name="l00222"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a572260b03bc8d5d23eb71f0c0e6193d0">  222</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnyValue.html">pointer</a> = <a class="code" href="structte_1_1AnyValue.html">value_type</a>*;</div><div class="line"><a name="l00224"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a70003fbdad1535a8ee15fba0b13d670b">  224</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnyValue.html">const_pointer</a> = <span class="keyword">const</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>*;</div><div class="line"><a name="l00227"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">  227</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> = std::unique_ptr&lt;value_type&gt;;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keyword">static</span> <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> next_highest_pow2(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> n)</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> i = 1;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">while</span>(i &lt;= n)</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        {</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            assert(i * 2 &gt; i);</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            i *= 2;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        }</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="keywordflow">return</span> i;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    }</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <a class="code" href="structte_1_1AnySet.html#a034124e5f924602e12198f57f8dc18ae">allocator_type</a> alloc_socca()<span class="keyword"> const</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        <span class="keywordflow">return</span> std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            get_allocator()</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        );</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    }</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> IsConst&gt; </div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="keyword">struct </span>BucketIterator:</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        <span class="keyword">public</span> std::conditional_t&lt;IsConst, const_iterator, iterator&gt;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    {</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html">self_type</a> = BucketIterator&lt;IsConst&gt;;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        <span class="keyword">using</span> base_type = std::conditional_t&lt;IsConst, const_iterator, iterator&gt;;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keyword">public</span>:</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        <span class="keyword">using</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>        = <span class="keyword">typename</span> base_type::value_type;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        <span class="keyword">using</span> <a class="code" href="structte_1_1AnyValue.html">reference</a>         = <span class="keyword">typename</span> base_type::reference;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        <span class="keyword">using</span> <a class="code" href="structte_1_1AnyValue.html">pointer</a>           = <span class="keyword">typename</span> base_type::pointer;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html#a9c6c0e28fee9b4a3f8ea81e2bd55e28b">difference_type</a>   = <span class="keyword">typename</span> base_type::difference_type;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> base_type::iterator_category;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        BucketIterator() = <span class="keywordflow">default</span>;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> BucketIterator&lt;IsConst&gt;&amp; left, <span class="keyword">const</span> BucketIterator&lt;IsConst&gt;&amp; right)</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        {</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <span class="keywordflow">if</span>((left.bucket_ != right.bucket_) or (left.mask_ != right.mask_))</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                <span class="comment">// Different buckets or different masks.</span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(left.get_pos().is_null())</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                <span class="comment">// Both are end sentinals or left is an end sentinal and right is past-the-end.</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                <span class="keywordflow">return</span> right.get_pos().is_null() or right.is_past_the_end();</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(right.get_pos().is_null())</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                <span class="comment">// Right is an end sentinal and left is past-the-end.</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                <span class="keywordflow">return</span> left.is_past_the_end();</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                <span class="comment">// Both point to the same value.</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                <span class="keywordflow">return</span> left.get_pos() == right.get_pos();</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        }</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> BucketIterator&lt;IsConst&gt;&amp; left, <span class="keyword">const</span> BucketIterator&lt;IsConst&gt;&amp; right)</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        { <span class="keywordflow">return</span> not (left == right); }</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keyword">private</span>:</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        BucketIterator(base_type pos, std::size_t bucket, std::size_t table_size):</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            base_type(pos), bucket_(bucket), mask_(table_size - 1u)</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        {</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            </div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        }</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keywordtype">bool</span> is_past_the_end()<span class="keyword"> const</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            <span class="comment">// Returns true if &#39;pos_&#39; is past-the-end for the whole list or the element pointed to by</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="comment">// &#39;pos_&#39; has a hash in a different bucket (past-the-end for this bucket).</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <span class="keywordflow">return</span> get_pos().is_end() or ((get_pos()-&gt;hash &amp; mask_) != bucket_);</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        }</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        BucketIterator&lt;false&gt; to_non_const()<span class="keyword"> const</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="keyword">        </span>{</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            <span class="keywordflow">return</span> BucketIterator&lt;false&gt;(</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                get_pos().to_non_const(), bucket_, mask_ + 1</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            );</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        }</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keyword">const</span> base_type&amp; get_pos()<span class="keyword"> const</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="keyword">        </span>{ <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>base_type&amp;<span class="keyword">&gt;</span>(*this); }</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        base_type&amp; get_pos()</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>base_type&amp;<span class="keyword">&gt;</span>(*this); }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        std::size_t bucket_{0};</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        std::size_t mask_{0};</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span>, <span class="keyword">class</span>, <span class="keyword">class</span>&gt;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="structte_1_1AnySet.html">AnySet</a>;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    };</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    </div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00318"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">  318</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">local_iterator</a> = BucketIterator&lt;false&gt;;</div><div class="line"><a name="l00320"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">  320</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> = BucketIterator&lt;true&gt;;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="keywordtype">void</span> _assert_invariants(<span class="keywordtype">bool</span> check_load_factor = <span class="keyword">false</span>)<span class="keyword"> const</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        list_._assert_invariants();</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        assert(table_size() &gt; 0u);</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        assert(((table_size() &amp; (table_size() - 1)) == 0u) and <span class="stringliteral">&quot;Table size not a power of two.&quot;</span>);</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        assert(max_load_factor_ &gt; 0.0);</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <span class="keyword">auto</span> iter_dist = std::distance(cbegin(), cend());</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        assert(iter_dist &gt;= 0);</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        assert(static_cast&lt;size_type&gt;(iter_dist) == size());</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        assert(std::all_of(table_.begin(), table_.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v){ <span class="keywordflow">return</span> v.is_null() or not v.is_end();}));</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <span class="keywordflow">for</span>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> i = 0; i &lt; bucket_count(); ++i)</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        {</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            <span class="comment">// each bucket is sorted WRT hash values of the nodes in the bucket</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            assert(std::is_sorted(begin(i), end(i), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; l, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; r){ <span class="keywordflow">return</span> l.hash &lt; r.hash; }));</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            assert(std::all_of(begin(i), end(i), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v){ <span class="keywordflow">return</span> bucket_index(v.hash) == i; }));</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        }</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="comment">// the load factor is allowed to be not satisfied if the user changed the max_load_factor().</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="comment">// we only do this assertion when asked to</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <span class="keywordflow">if</span>(check_load_factor)</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;            assert(load_factor_satisfied());</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    }</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    ~<a class="code" href="structte_1_1AnySet.html">AnySet</a>() = <span class="keywordflow">default</span>;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00352"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a8889bd44aeb88168a6a7ffb277b5c0cd">  352</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a8889bd44aeb88168a6a7ffb277b5c0cd">AnySet</a>(): <a class="code" href="structte_1_1AnySet.html">AnySet</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>(0)) { }</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a966efeede2c85ea0e11b7af0366119ec">  361</a></span>&#160;    <span class="keyword">explicit</span> <a class="code" href="structte_1_1AnySet.html#a966efeede2c85ea0e11b7af0366119ec">AnySet</a>(</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count,</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <span class="keyword">const</span> HashFn&amp; hash = HashFn(),</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keyword">const</span> KeyEqual&amp; equal = KeyEqual(),</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc = Allocator()</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    ):</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        <a class="code" href="structte_1_1CompressedPair.html">pair_type</a>(hash, equal),</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        table_(next_highest_pow2(bucket_count), <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>(), <a class="code" href="structte_1_1AnySet.html#a034124e5f924602e12198f57f8dc18ae">allocator_type</a>(alloc))</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    {</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        </div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a6a64b737fb06974c4658dff89717f252">  378</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a6a64b737fb06974c4658dff89717f252">AnySet</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count, <span class="keyword">const</span> Allocator&amp; alloc):</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(bucket_count, HashFn(), KeyEqual(), alloc) </div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    {</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        </div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    }</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    </div><div class="line"><a name="l00390"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a158e154a3d03b13e4a035342bfe70569">  390</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a158e154a3d03b13e4a035342bfe70569">AnySet</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count, <span class="keyword">const</span> HashFn&amp; hash, <span class="keyword">const</span> Allocator&amp; alloc):</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(bucket_count, hash, KeyEqual(), alloc)</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    {</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        </div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    }</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIt&gt;</div><div class="line"><a name="l00411"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ab4e3a32bb198fb9a4de9a8917c1123f2">  411</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#ab4e3a32bb198fb9a4de9a8917c1123f2">AnySet</a>(</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        InputIt first, </div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        InputIt last,</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count = 0,</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="keyword">const</span> HashFn&amp; hash = HashFn(),</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="keyword">const</span> KeyEqual&amp; equal = KeyEqual(),</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc = Allocator()</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    ):</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(bucket_count, hash, equal, alloc)</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    {</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        insert(first, last);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    }</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIt&gt;</div><div class="line"><a name="l00437"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a8e098e80fdf2b2192319ff76d601a1c3">  437</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a8e098e80fdf2b2192319ff76d601a1c3">AnySet</a>(</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        InputIt first, </div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        InputIt last,</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count,</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    ):</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(first, last, bucket_count, HashFn(), KeyEqual(), alloc)</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    {</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        </div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    }</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIt&gt;</div><div class="line"><a name="l00462"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a9b1df747c2198efd5efe5ba16bfb314d">  462</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a9b1df747c2198efd5efe5ba16bfb314d">AnySet</a>(</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        InputIt first, </div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        InputIt last,</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count,</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="keyword">const</span> HashFn&amp; hash,</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    ):</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(first, last, bucket_count, hash, KeyEqual(), alloc)</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    {</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        </div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    }</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#adc47a853ec464d1e32b53b9747156747">  481</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#adc47a853ec464d1e32b53b9747156747">AnySet</a>(<span class="keyword">const</span> <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; other, <span class="keyword">const</span> Allocator&amp; alloc):</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <a class="code" href="structte_1_1CompressedPair.html">pair_type</a>(other.as_pair()),</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        list_(other.list_),</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        table_(0, alloc),</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;        max_load_factor_(other.max_load_factor_)</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    {</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;        table_.assign(other.table_.size(), <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>());</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        <a class="code" href="classte_1_1detail_1_1AnyList.html">list_type</a> tmp(std::move(list_));</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        assert(size() == 0u);</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> node{<span class="keyword">nullptr</span>};</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        <span class="keywordflow">while</span>(not tmp.empty())</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        {</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;            node = std::move(tmp.pop(tmp.begin()).first);</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            node = std::move(push(std::move(node)));</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;            assert(not static_cast&lt;bool&gt;(node));</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        }</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        assert(tmp.empty());</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    }</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ae6aa2884c8d394bf7eeb6459224307c6">  507</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#ae6aa2884c8d394bf7eeb6459224307c6">AnySet</a>(<span class="keyword">const</span> <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; other):</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <a class="code" href="structte_1_1CompressedPair.html">pair_type</a>(other.as_pair()),</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        list_(other.list_, <a class="code" href="classte_1_1detail_1_1AnyList.html">list_type</a>::make_copy),</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        table_(0, other.alloc_socca()),</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        max_load_factor_(other.max_load_factor_)</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    {</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        table_.resize(other.table_.size());</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;        <a class="code" href="classte_1_1detail_1_1AnyList.html">list_type</a> tmp(std::move(list_));</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        assert(size() == 0u);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> node{<span class="keyword">nullptr</span>};</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        <span class="keywordflow">while</span>(not tmp.empty())</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        {</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;            node = std::move(tmp.pop(tmp.begin()).first);</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;            node = std::move(push(std::move(node)).second);</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;            assert(not static_cast&lt;bool&gt;(node));</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        }</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        assert(tmp.empty());</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    }</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a226874c61eb1eb38eee1f2ce0ab990a4">  533</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a226874c61eb1eb38eee1f2ce0ab990a4">AnySet</a>(<a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp;&amp; other, <span class="keyword">const</span> Allocator&amp; alloc):</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        <a class="code" href="structte_1_1CompressedPair.html">pair_type</a>(std::move(other.as_pair())),</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        list_(std::move(other.list_)),</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        table_(std::move(other.table_), alloc),</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        max_load_factor_(other.max_load_factor_)</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    {</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        fix_table_after_move();</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;        assert(other.empty());</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;        <span class="keywordflow">if</span>(other.table_.size() == 0u)</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;            other.table_.assign(1u, <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>());</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    }</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a65383e7f9deaaa338bf4a016a7106f72">  552</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a65383e7f9deaaa338bf4a016a7106f72">AnySet</a>(<a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp;&amp; other):</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        <a class="code" href="structte_1_1CompressedPair.html">pair_type</a>(std::move(other.as_pair())),</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        list_(std::move(other.list_)),</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        table_(std::move(other.table_)),</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        max_load_factor_(other.max_load_factor_)</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    {</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        fix_table_after_move();</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        assert(other.empty());</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="keywordflow">if</span>(other.table_.size() == 0u)</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;            other.table_.assign(1u, <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>());</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    }</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l00579"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a584bb61c6139493b3ca4859d261d09e6">  579</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a584bb61c6139493b3ca4859d261d09e6">AnySet</a>(</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        std::initializer_list&lt;T&gt; ilist,</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count = 0,</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;        <span class="keyword">const</span> HashFn&amp; hash = HashFn(),</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        <span class="keyword">const</span> KeyEqual&amp; equal = KeyEqual(),</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc = Allocator()</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    ):</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(ilist.begin(), ilist.end(), bucket_count, hash, equal, alloc)</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    {</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;        </div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    }</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l00604"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#abd1bc5833fb79e44ef1dcdd5e3c88bcf">  604</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#abd1bc5833fb79e44ef1dcdd5e3c88bcf">AnySet</a>(</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        std::initializer_list&lt;T&gt; ilist,</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count,</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    ):</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(ilist, bucket_count, HashFn(), KeyEqual(), alloc)</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    {</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;        </div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    }</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l00628"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#aa168fffe9f11ad2ebde217740baa1cbf">  628</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#aa168fffe9f11ad2ebde217740baa1cbf">AnySet</a>(</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        std::initializer_list&lt;T&gt; ilist,</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count,</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        <span class="keyword">const</span> HashFn&amp; hash,</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    ):</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(ilist, bucket_count, hash, KeyEqual(), alloc)</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    {</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;        </div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    }</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class </span>... T&gt;</div><div class="line"><a name="l00653"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a15ab2e1618e11f308fee56d1e840b603">  653</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a15ab2e1618e11f308fee56d1e840b603">AnySet</a>(</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;        std::tuple&lt;T ...&gt;&amp;&amp; tup,</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count = 2 * (<span class="keyword">sizeof</span>...(T)),</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;        <span class="keyword">const</span> HashFn&amp; hash = HashFn(),</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;        <span class="keyword">const</span> KeyEqual&amp; equal = KeyEqual(),</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc = Allocator()</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    ):</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(bucket_count, hash, equal, alloc)</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    {</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;        std::apply(</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;            [&amp;](<span class="keyword">auto</span>&amp;&amp; ... args) { </div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                this-&gt;arg_insert(std::forward&lt;decltype(args)&gt;(args)...); </div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;            },</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;            std::move(tup)</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;        );</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;        </div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    }</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class </span>... T&gt;</div><div class="line"><a name="l00683"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a0366d2d6867776b8ebfacaa167b4a5b0">  683</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a0366d2d6867776b8ebfacaa167b4a5b0">AnySet</a>(</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;        std::tuple&lt;T ...&gt;&amp;&amp; tup,</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count,</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    ):</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(std::move(tup), bucket_count, HashFn(), KeyEqual(), alloc)</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    {</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;        </div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    }</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class </span>... T&gt;</div><div class="line"><a name="l00706"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#aadd6af9b081ad61a07e81090334614e2">  706</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#aadd6af9b081ad61a07e81090334614e2">AnySet</a>(</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;        std::tuple&lt;T ...&gt;&amp;&amp; tup,</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_count,</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;        <span class="keyword">const</span> HashFn&amp; hash,</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;        <span class="keyword">const</span> Allocator&amp; alloc</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    ):</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;        <a class="code" href="structte_1_1AnySet.html">AnySet</a>(std::move(tup), bucket_count, hash, KeyEqual(), alloc)</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    {</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;        </div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    }</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;</div><div class="line"><a name="l00733"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#aadc20b7c67d5c635b2c54b9b2f00ae40">  733</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="code" href="structte_1_1AnySet.html#aadc20b7c67d5c635b2c54b9b2f00ae40">operator=</a>(<span class="keyword">const</span> <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; other)</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    { <span class="keywordflow">return</span> *<span class="keyword">this</span> = std::move(<a class="code" href="structte_1_1AnySet.html">self_type</a>(other)); }</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;</div><div class="line"><a name="l00744"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#acf3ff8ce9e70828b4240a67129eb5e83">  744</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="code" href="structte_1_1AnySet.html#acf3ff8ce9e70828b4240a67129eb5e83">operator=</a>(<a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp;&amp; other) noexcept(std::is_nothrow_move_assignable_v&lt;vector_type&gt;)</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;    {</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;        as_pair() = std::move(other.as_pair());</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        list_ = std::move(other.list_);</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;        table_ = std::move(other.table_);</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        max_load_factor_ = std::move(other.max_load_factor_);</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;        fix_table_after_move();</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;        assert(other.empty());</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        <span class="keywordflow">if</span>(other.table_.size() == 0u)</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;            other.table_.assign(1u, <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>());</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;    }</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l00765"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#aada8bfe6c1bbc1e2300d8eeaf6621c1b">  765</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="code" href="structte_1_1AnySet.html#aada8bfe6c1bbc1e2300d8eeaf6621c1b">operator=</a>(std::initializer_list&lt;T&gt; ilist)</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    { <span class="keywordflow">return</span> *<span class="keyword">this</span> = <a class="code" href="structte_1_1AnySet.html">self_type</a>(ilist); }</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;</div><div class="line"><a name="l00778"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a4573f5334af88c606b3f73da6c6c0916">  778</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="code" href="structte_1_1AnySet.html#a4573f5334af88c606b3f73da6c6c0916">cbegin</a>()<span class="keyword"> const</span></div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> list_.cbegin(); }</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;</div><div class="line"><a name="l00786"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a88d77aa672a65bf4adf8f7811ea8180b">  786</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="code" href="structte_1_1AnySet.html#a88d77aa672a65bf4adf8f7811ea8180b">begin</a>()<span class="keyword"> const</span></div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> cbegin(); }</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;</div><div class="line"><a name="l00794"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00">  794</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="code" href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00">begin</a>() </div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;    { <span class="keywordflow">return</span> list_.begin(); }</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;</div><div class="line"><a name="l00802"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a60ea6c78bad173c6f63152992efa364a">  802</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="code" href="structte_1_1AnySet.html#a60ea6c78bad173c6f63152992efa364a">cend</a>()<span class="keyword"> const</span></div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> list_.cend(); }</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div><div class="line"><a name="l00810"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a6f4e76a019d6e5e20c66ef9c32d6b3ee">  810</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="code" href="structte_1_1AnySet.html#a6f4e76a019d6e5e20c66ef9c32d6b3ee">end</a>()<span class="keyword"> const</span></div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> cend(); }</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;</div><div class="line"><a name="l00818"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64">  818</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="code" href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64">end</a>()</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;    { <span class="keywordflow">return</span> list_.end(); }</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;    [[nodiscard]]</div><div class="line"><a name="l00832"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a393e3a7a552f2d5cda17ee0bfa0a251e">  832</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="structte_1_1AnySet.html#a393e3a7a552f2d5cda17ee0bfa0a251e">empty</a>() const noexcept</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;    { <span class="keywordflow">return</span> not <span class="keyword">static_cast&lt;</span><span class="keywordtype">bool</span><span class="keyword">&gt;</span>(size()); }</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00840"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#aa82c525d87429e9586026c549d5fca34">  840</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="code" href="structte_1_1AnySet.html#aa82c525d87429e9586026c549d5fca34">size</a>() const noexcept</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;    { <span class="keywordflow">return</span> list_.size(); }</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;</div><div class="line"><a name="l00850"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a8ca85fcaf35763f2339e77bbf93f505e">  850</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="structte_1_1AnySet.html#a8ca85fcaf35763f2339e77bbf93f505e">max_size</a>() const noexcept</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;    { <span class="keywordflow">return</span> std::numeric_limits&lt;typename list_type::size_type&gt;::max(); }</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;</div><div class="line"><a name="l00862"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a3cf95080869e749c8e06cf7f4f9130a4">  862</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="structte_1_1AnySet.html#a3cf95080869e749c8e06cf7f4f9130a4">clear</a>() noexcept</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;    {</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;        list_.clear();</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;        std::fill(table_.begin(), table_.end(), <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>());</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;    }</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    </div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>... Args&gt;</div><div class="line"><a name="l00892"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ae1714daaedbc435c19d0bd94320a3d15">  892</a></span>&#160;    std::pair&lt;iterator, bool&gt; <a class="code" href="structte_1_1AnySet.html#ae1714daaedbc435c19d0bd94320a3d15">emplace</a>(Args&amp;&amp; ... args)</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    {</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;        static_assert(</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;            std::is_same_v&lt;T, std::decay_t&lt;T&gt;&gt;,</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;            <span class="stringliteral">&quot;Cannot emplace references, arrays, or functions into an AnySet.&quot;</span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;        );</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;        <span class="keyword">auto</span> node(make_any_value&lt;T, HashFn, KeyEqual&gt;(get_hasher(), std::forward&lt;Args&gt;(args)...));</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;        <span class="keyword">auto</span> hash_v = node-&gt;hash;</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;        KeyInfo&lt;T&gt; ki{unsafe_cast&lt;<span class="keyword">const</span> T&amp;&gt;(*node), hash_v, bucket_index(hash_v)};</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;        <span class="keywordflow">return</span> insert_impl&lt;true&gt;(ki.value, ki, std::move(node));</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    }</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    </div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>... Args&gt;</div><div class="line"><a name="l00933"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ae5e4dcb2691ff7bca954aa1b6e8a7f3d">  933</a></span>&#160;    std::pair&lt;iterator, bool&gt; <a class="code" href="structte_1_1AnySet.html#ae5e4dcb2691ff7bca954aa1b6e8a7f3d">emplace_hint</a>([[maybe_unused]] <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> hint, Args&amp;&amp; ... args)</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    { <span class="keywordflow">return</span> emplace&lt;T&gt;(std::forward&lt;Args&gt;(args)...); }</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l00950"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a9e113b687669fcc70d2aab15581eba4b">  950</a></span>&#160;    std::pair&lt;iterator, bool&gt; <a class="code" href="structte_1_1AnySet.html#a9e113b687669fcc70d2aab15581eba4b">insert</a>(T&amp;&amp; value)</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;    {</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;        <span class="keywordflow">return</span> insert_impl&lt;true&gt;(std::forward&lt;T&gt;(value), make_key_info(value));</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;    }</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l00972"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#af5963685181390d0b2730e401a38998c">  972</a></span>&#160;    std::pair&lt;iterator, bool&gt; <a class="code" href="structte_1_1AnySet.html#af5963685181390d0b2730e401a38998c">insert</a>([[maybe_unused]] <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> hint, T&amp;&amp; value)</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    { <span class="keywordflow">return</span> insert(std::forward&lt;T&gt;(value)); }</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;    <span class="keyword">template</span> &lt;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;        <span class="keyword">class </span>It, </div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;        <span class="keyword">class </span>= std::enable_if_t&lt;</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;            std::is_copy_constructible_v&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;            or std::is_rvalue_reference_v&lt;decltype(*std::declval&lt;It&gt;())&gt;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;        &gt;</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;    &gt;</div><div class="line"><a name="l00997"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ab6777a564b3a11d8e0eb3936f1f98376">  997</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="code" href="structte_1_1AnySet.html#ab6777a564b3a11d8e0eb3936f1f98376">insert</a>(It first, It last)</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    {</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;        <span class="keyword">using</span> iter_cat = <span class="keyword">typename</span> std::iterator_traits&lt;It&gt;::iterator_category;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;        <span class="keywordflow">return</span> range_insert(first, last, iter_cat{});</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    }</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    <span class="keyword">template</span> &lt;</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;        <span class="keyword">class </span>T, </div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;        <span class="keyword">class </span>U, </div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;        <span class="keyword">class </span>... V,</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;        <span class="keyword">class </span>= std::enable_if_t&lt;</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;            (not (std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt; and detail::is_iterator_v&lt;std::decay_t&lt;T&gt;&gt;))</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;            and (not std::is_same_v&lt;std::decay_t&lt;T&gt;, <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>&gt;)</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;            and (not std::is_same_v&lt;std::decay_t&lt;T&gt;, <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>&gt;)</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;        &gt;</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;    &gt;</div><div class="line"><a name="l01031"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#aaf7d6344803cdd2c500fc69195caafa5"> 1031</a></span>&#160;    std::bitset&lt;2ull + <span class="keyword">sizeof</span>...(V)&gt; <a class="code" href="structte_1_1AnySet.html#aaf7d6344803cdd2c500fc69195caafa5">insert</a>(T&amp;&amp; first, U&amp;&amp; second, V&amp;&amp; ... args)</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;    {</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;        <span class="keywordflow">return</span> arg_insert(</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;            std::forward&lt;T&gt;(first),</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;            std::forward&lt;U&gt;(second),</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;            std::forward&lt;V&gt;(args) ...</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;        );</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;    }</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;    </div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> = std::enable_if_t&lt;std::is_copy_constructible_v&lt;T&gt;&gt;&gt;</div><div class="line"><a name="l01057"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a2bb9858e05bfa98608ce5f5dedcffb89"> 1057</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="code" href="structte_1_1AnySet.html#a2bb9858e05bfa98608ce5f5dedcffb89">insert</a>(std::initializer_list&lt;T&gt; ilist)</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;    {</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;        <span class="keywordflow">return</span> insert(ilist.begin(), ilist.end());</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    }</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;</div><div class="line"><a name="l01073"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a9f7ff5aaba81710bfe649d6e8932b8e1"> 1073</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="code" href="structte_1_1AnySet.html#a9f7ff5aaba81710bfe649d6e8932b8e1">erase</a>(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos)</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;    {</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;        <span class="keywordflow">return</span> pop(pos).second;</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;    }</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;</div><div class="line"><a name="l01093"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a0359ac488a6fc12708c5b4bd88651faa"> 1093</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="code" href="structte_1_1AnySet.html#a0359ac488a6fc12708c5b4bd88651faa">erase</a>(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> first, <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> last)</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;    {</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> pos = first.to_non_const();</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;        <span class="keywordflow">if</span>(first == last)</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;            <span class="keywordflow">return</span> pos;</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;        <span class="keywordflow">do</span> {</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;            <span class="comment">// hop over &#39;pos&#39; and check if we&#39;ve reached the end</span></div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;            <span class="keyword">auto</span> nxt = std::next(first);</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;            done = (nxt == last);</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;            pos = erase(pos);</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;        } <span class="keywordflow">while</span>(not done);</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;        <span class="keywordflow">return</span> pos.to_non_const();</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;    }</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> = std::enable_if_t&lt;not (std::is_same_v&lt;const_iterator, T&gt; or std::is_same_v&lt;iterator, T&gt;)&gt;&gt;</div><div class="line"><a name="l01121"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a87c303c97a54cb06c2e32f4cf7550202"> 1121</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="code" href="structte_1_1AnySet.html#a87c303c97a54cb06c2e32f4cf7550202">erase</a>(<span class="keyword">const</span> T&amp; value)</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    {</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;        <span class="keyword">auto</span> [pos, found] = find_position(make_key_info(value));</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;        <span class="keywordflow">if</span>(found)</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;            erase(pos);</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a><span class="keyword">&gt;</span>(found);</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;    }</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;</div><div class="line"><a name="l01140"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a81b4b02feab7c4ae295488622fd80485"> 1140</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="structte_1_1AnySet.html#a81b4b02feab7c4ae295488622fd80485">swap</a>(<a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; other) </div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;        noexcept(std::is_nothrow_swappable_v&lt;vector_type&gt; and std::is_nothrow_swappable_v&lt;pair_type&gt;)</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;    {</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;        <span class="keyword">using</span> std::swap;</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;        swap(as_pair(), other.as_pair());</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;        swap(list_, other.list_);</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;        swap(table_, other.table_);</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;        swap(max_load_factor_, other.max_load_factor_);</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;        this-&gt;fix_table_after_move();</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;        other.fix_table_after_move();</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    }</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;</div><div class="line"><a name="l01165"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#abc4a188e3477bb2fd20ed77832b2eca3"> 1165</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="code" href="structte_1_1AnySet.html#abc4a188e3477bb2fd20ed77832b2eca3">update</a>(<span class="keyword">const</span> <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; other)</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;    {</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;        preemptive_reserve(other.<a class="code" href="structte_1_1AnySet.html#aa82c525d87429e9586026c549d5fca34">size</a>());</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; any_v: other)</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;        {</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;            <span class="keyword">auto</span> [pos, found] = find_position(any_v);</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;            <span class="keywordflow">if</span>(not found)</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;            unsafe_splice_at(pos, any_v.clone());</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;        }</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;        assert(load_factor_satisfied());</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;    }</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;</div><div class="line"><a name="l01202"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a42cffd4ef597d50514bd84509c4ddb9a"> 1202</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; <a class="code" href="structte_1_1AnySet.html#a42cffd4ef597d50514bd84509c4ddb9a">update</a>(<a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp;&amp; other)</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;    {</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;        preemptive_reserve(other.size());</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">auto</span> pos = other.begin(); pos != other.end(); )</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;        {</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;            <span class="keyword">auto</span> [ins_pos, found] = find_position(*pos);</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;            <span class="keywordflow">if</span>(not found)</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;            {</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;                ++pos;</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;            }</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;            unsafe_splice_at(ins_pos, other.pop(pos));</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;        }</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;    }</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l01233"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a4f779a63cfdc23f956c4a969fe2787f1"> 1233</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="code" href="structte_1_1AnySet.html#a4f779a63cfdc23f956c4a969fe2787f1">count</a>(<span class="keyword">const</span> T&amp; value)<span class="keyword"> const</span></div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a><span class="keyword">&gt;</span>(</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;            find_position(make_key_info(value)).second</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;        );</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;    }</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l01249"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a745cebbb374f1ca26895758efe9d12f0"> 1249</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> <a class="code" href="structte_1_1AnySet.html#a745cebbb374f1ca26895758efe9d12f0">find</a>(<span class="keyword">const</span> T&amp; value)<span class="keyword"> const</span></div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;        <span class="keyword">auto</span> [pos, found] = find_position(make_key_info(value));</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;        <span class="keywordflow">if</span>(found)</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;            <span class="keywordflow">return</span> pos;</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;            <span class="keywordflow">return</span> cend();</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;    }</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l01267"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#afc8dfbeda6635887a184596301667241"> 1267</a></span>&#160;    <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> <a class="code" href="structte_1_1AnySet.html#afc8dfbeda6635887a184596301667241">find</a>(<span class="keyword">const</span> T&amp; value)</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;    {</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="structte_1_1AnySet.html">self_type</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;find(value).to_non_const();</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;    }</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l01283"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a842f26f8ec56caf35806a2345a1ec70f"> 1283</a></span>&#160;    std::pair&lt;const_iterator, const_iterator&gt; <a class="code" href="structte_1_1AnySet.html#a842f26f8ec56caf35806a2345a1ec70f">equal_range</a>(<span class="keyword">const</span> T&amp; value)<span class="keyword"> const</span></div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;        <span class="keyword">auto</span> pos = find(value);</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;        <span class="keywordflow">if</span>(pos != cend())</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;            <span class="keywordflow">return</span> std::make_pair(pos, std::next(pos));</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;            <span class="keywordflow">return</span> std::make_pair(cend(), cend());</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;    }</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l01303"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a1a526cfab6e3e4dd20607793aa346c14"> 1303</a></span>&#160;    std::pair&lt;iterator, iterator&gt; <a class="code" href="structte_1_1AnySet.html#a1a526cfab6e3e4dd20607793aa346c14">equal_range</a>(<span class="keyword">const</span> T&amp; value)</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;    {</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;        <span class="keyword">auto</span> [first, last] = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="structte_1_1AnySet.html">self_type</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;equal_range(value);</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;        <span class="keywordflow">return</span> std::make_pair(</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;            first.to_non_const(),</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;            last.to_non_const()</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;        );</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;    }</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;</div><div class="line"><a name="l01321"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a09f98db8233ff48a60d035be2fdcdf8f"> 1321</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="structte_1_1AnySet.html#a09f98db8233ff48a60d035be2fdcdf8f">contains_value</a>(<span class="keyword">const</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>&amp; any_v)<span class="keyword"> const</span></div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;        <span class="keywordflow">return</span> contains(any_v);</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;    }</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;</div><div class="line"><a name="l01335"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a7e71e3f3d875be2fa422f5a2f7dbcad4"> 1335</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="structte_1_1AnySet.html#a7e71e3f3d875be2fa422f5a2f7dbcad4">contains_value_eq</a>(<span class="keyword">const</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>&amp; any_v)<span class="keyword"> const</span></div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> find_matching_value(any_v) != cend(); }</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;</div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l01348"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ab6daa7e3909a5db260d005b68aeb75c2"> 1348</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="structte_1_1AnySet.html#ab6daa7e3909a5db260d005b68aeb75c2">contains</a>(<span class="keyword">const</span> T&amp; value)<span class="keyword"> const</span></div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;        <span class="keywordflow">return</span> count(value);</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;    }</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;    </div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l01362"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#abd1f7f079a1a7fd7b7225f7a2fcb053c"> 1362</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="structte_1_1AnySet.html#abd1f7f079a1a7fd7b7225f7a2fcb053c">contains_eq</a>(<span class="keyword">const</span> T&amp; value)<span class="keyword"> const</span></div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> find_matching_value(value) != cend(); }</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;    </div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;</div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;</div><div class="line"><a name="l01377"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a6308245ef5e820524422bc4b743f0d3b"> 1377</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> <a class="code" href="structte_1_1AnySet.html#a6308245ef5e820524422bc4b743f0d3b">cbegin</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck)<span class="keyword"> const</span></div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;        assert(buck &lt; bucket_count());</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a>(table_[buck], buck, table_size());</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;    }</div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;</div><div class="line"><a name="l01390"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ab05d8e4bbd99e067be35975ae5e9437a"> 1390</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> <a class="code" href="structte_1_1AnySet.html#ab05d8e4bbd99e067be35975ae5e9437a">begin</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck)<span class="keyword"> const</span></div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> cbegin(buck); }</div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;</div><div class="line"><a name="l01400"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a32aed526754d1d08abafcf3ca927199e"> 1400</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">local_iterator</a> <a class="code" href="structte_1_1AnySet.html#a32aed526754d1d08abafcf3ca927199e">begin</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck)</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    { <span class="keywordflow">return</span> cbegin(buck).to_non_const(); }</div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;</div><div class="line"><a name="l01412"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a2547dfd6591204e184ed9a41a8119f99"> 1412</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> <a class="code" href="structte_1_1AnySet.html#a2547dfd6591204e184ed9a41a8119f99">cend</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck)<span class="keyword"> const</span></div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;        assert(buck &lt; bucket_count());</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a>(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>(), buck, table_size());</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;    }</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;</div><div class="line"><a name="l01427"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a9c62381e07490eedda0fe18bf0f70ec2"> 1427</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">const_local_iterator</a> <a class="code" href="structte_1_1AnySet.html#a9c62381e07490eedda0fe18bf0f70ec2">end</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck)<span class="keyword"> const</span></div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> cend(buck); }</div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;</div><div class="line"><a name="l01439"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a5ae18a17ec71db70fe41cd44d2b95962"> 1439</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">local_iterator</a> <a class="code" href="structte_1_1AnySet.html#a5ae18a17ec71db70fe41cd44d2b95962">end</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck)</div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;    { <span class="keywordflow">return</span> cend(buck).to_non_const(); }</div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;</div><div class="line"><a name="l01447"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57"> 1447</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="code" href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">bucket_count</a>() const noexcept</div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;    { <span class="keywordflow">return</span> table_size(); }</div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;</div><div class="line"><a name="l01455"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a9d45dba54805315e0c4affc8ee6178d4"> 1455</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="code" href="structte_1_1AnySet.html#a9d45dba54805315e0c4affc8ee6178d4">max_bucket_count</a>() const noexcept</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;    { </div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> maxm = ~((~<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a>(0)) &gt;&gt; 1);</div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;        <span class="keywordflow">while</span>(maxm &gt; table_.max_size())</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;            maxm &gt;&gt;= 1;</div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;        <span class="keywordflow">return</span> maxm;</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;    }</div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;</div><div class="line"><a name="l01470"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a08203fd19a36ef68255105b86542eb5b"> 1470</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="code" href="structte_1_1AnySet.html#a08203fd19a36ef68255105b86542eb5b">bucket_size</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck)<span class="keyword"> const</span></div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;        assert(buck &lt; bucket_count());</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a><span class="keyword">&gt;</span>(</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;            std::distance(cbegin(buck), cend(buck))</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;        );</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;    }</div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;</div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><a name="l01486"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ae61121307fc50fb15fa3e5550baad61c"> 1486</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> <a class="code" href="structte_1_1AnySet.html#ae61121307fc50fb15fa3e5550baad61c">bucket</a>(<span class="keyword">const</span> T&amp; value)<span class="keyword"> const</span></div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> bucket_index(get_hasher()(value)); }</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;</div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;</div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;</div><div class="line"><a name="l01501"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998"> 1501</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998">max_load_factor</a>(<span class="keywordtype">float</span> f)</div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;    {</div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;        assert(f &gt; 0.0);</div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;        max_load_factor_ = f;</div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;    }</div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;    </div><div class="line"><a name="l01512"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a5106dea17f03564a1450f9649ba6741a"> 1512</a></span>&#160;    <span class="keywordtype">float</span> <a class="code" href="structte_1_1AnySet.html#a5106dea17f03564a1450f9649ba6741a">max_load_factor</a>() const noexcept</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;    { <span class="keywordflow">return</span> max_load_factor_; }</div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;</div><div class="line"><a name="l01520"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#abee36ac47b617f947a08038541f387f2"> 1520</a></span>&#160;    <span class="keywordtype">float</span> <a class="code" href="structte_1_1AnySet.html#abee36ac47b617f947a08038541f387f2">load_factor</a>() const noexcept</div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(size()) / table_size(); }</div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;    </div><div class="line"><a name="l01534"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ac690ea857e56a70502d58aaf928e684e"> 1534</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="structte_1_1AnySet.html#ac690ea857e56a70502d58aaf928e684e">rehash</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> nbuckets)</div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;    {</div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bcount = bucket_count();</div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;        assert(bcount &gt; 0u);</div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;        <span class="keyword">auto</span> load_factor_good = [&amp;]() {</div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;            <span class="keywordflow">return</span> (static_cast&lt;double&gt;(size()) / bcount) &lt;= max_load_factor_;</div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;        };</div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;        <span class="keywordflow">if</span>(nbuckets &lt; bcount)</div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;        {</div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;            <span class="keywordflow">while</span>(nbuckets &lt; bcount and load_factor_good())</div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;                bcount /= 2;</div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;            <span class="keywordflow">if</span>((bcount == bucket_count()) and load_factor_good())</div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;                <span class="keywordflow">return</span>;</div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;            </div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;        }</div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nbuckets &gt; bcount)</div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;        {</div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;            <span class="keywordflow">while</span>(nbuckets &gt; bcount)</div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;                bcount *= 2;</div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;        }</div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;        <span class="keywordflow">while</span>(not load_factor_good())</div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;            bcount *= 2;</div><div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;        <span class="keywordflow">if</span>(bcount &gt; bucket_count())</div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;            grow_table(bcount);</div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(bcount &lt; bucket_count())</div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;            shrink_table(bcount);</div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;    }</div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;</div><div class="line"><a name="l01573"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a08dab7ac900042f7066c1ffa0b3c5375"> 1573</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="structte_1_1AnySet.html#a08dab7ac900042f7066c1ffa0b3c5375">reserve</a>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> count)</div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;    {</div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;        rehash(static_cast&lt;size_type&gt;(std::ceil(count / max_load_factor())));</div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;    }</div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;</div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;</div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;</div><div class="line"><a name="l01588"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a608c436f9887dcf4a7a7277e1ad2115e"> 1588</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a8d67e0b2dc842b7f6b858b974b694e4f">hasher</a> <a class="code" href="structte_1_1AnySet.html#a608c436f9887dcf4a7a7277e1ad2115e">hash_function</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> get_hasher(); }</div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;</div><div class="line"><a name="l01596"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a58b7e99fd9f0725a1874533f519c3ff1"> 1596</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a8ad77e4efb4d9e761042f816af59a4a4">key_equal</a> <a class="code" href="structte_1_1AnySet.html#a58b7e99fd9f0725a1874533f519c3ff1">key_eq</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> get_key_equal(); }</div><div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;</div><div class="line"><a name="l01604"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#af42ca9179c0e818ae81bea5194d3a7c9"> 1604</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a034124e5f924602e12198f57f8dc18ae">allocator_type</a> <a class="code" href="structte_1_1AnySet.html#af42ca9179c0e818ae81bea5194d3a7c9">get_allocator</a>()<span class="keyword"> const</span></div><div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> table_.get_allocator(); }</div><div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;</div><div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;</div><div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;</div><div class="line"><a name="l01618"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a074e520f91cc54b3df3d1278c9944367"> 1618</a></span>&#160;    <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="structte_1_1AnySet.html#a074e520f91cc54b3df3d1278c9944367">swap</a>(<a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; left, <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; right)</div><div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;    { <span class="keywordflow">return</span> left.<a class="code" href="structte_1_1AnySet.html#a81b4b02feab7c4ae295488622fd80485">swap</a>(right); }</div><div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;</div><div class="line"><a name="l01634"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#aa0195a9b300310dd1d599faec16f9c8c"> 1634</a></span>&#160;    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structte_1_1AnySet.html#aa0195a9b300310dd1d599faec16f9c8c">operator==</a>(<span class="keyword">const</span> <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; left, <span class="keyword">const</span> <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; right)</div><div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;    {</div><div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;        left._assert_invariants();</div><div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;        right._assert_invariants();</div><div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;        <span class="keywordflow">if</span>(left.<a class="code" href="structte_1_1AnySet.html#aa82c525d87429e9586026c549d5fca34">size</a>() != right.<a class="code" href="structte_1_1AnySet.html#aa82c525d87429e9586026c549d5fca34">size</a>())</div><div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;        <span class="comment">// iterate over the set with the smaller table.</span></div><div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; iter_set = (left.table_size() &gt; right.table_size()) ? right : left;</div><div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;        <span class="comment">// search through the set with the larger table</span></div><div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; search_set = (&amp;left == &amp;iter_set) ? right : left;</div><div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item: iter_set)</div><div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;        {</div><div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;            <span class="keyword">auto</span> pos = search_set.find_matching_value(item);</div><div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;            <span class="keywordflow">if</span>(pos.is_end())</div><div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;            {</div><div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;            }</div><div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;        }</div><div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;    }</div><div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;</div><div class="line"><a name="l01668"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a37c46f2275e85ea21dfd2919fe0981fd"> 1668</a></span>&#160;    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structte_1_1AnySet.html#a37c46f2275e85ea21dfd2919fe0981fd">operator!=</a>(<span class="keyword">const</span> <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; left, <span class="keyword">const</span> <a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; right)</div><div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;    { <span class="keywordflow">return</span> not (left == right); }</div><div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;</div><div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;</div><div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;</div><div class="line"><a name="l01693"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a65ce349ff5b24b0496c87a3fe7a3a997"> 1693</a></span>&#160;    std::pair&lt;node_handle, iterator&gt; <a class="code" href="structte_1_1AnySet.html#a65ce349ff5b24b0496c87a3fe7a3a997">pop</a>(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos_)</div><div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;    {</div><div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;        assert(not pos_.is_end());</div><div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;        assert(not pos_.is_null());</div><div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;</div><div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> pos = pos_.to_non_const();</div><div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck_idx = iter_bucket_index(pos);</div><div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> bucket_head = table_[buck_idx];</div><div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;</div><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;        assert(not bucket_head.is_null());</div><div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;        assert(not bucket_head.is_end());</div><div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;</div><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;        <span class="keywordflow">if</span>(bucket_head == pos)</div><div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;        {</div><div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;            <span class="comment">// &#39;pos&#39; is the first item in its bucket.</span></div><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;            <span class="keyword">auto</span> [node, next] = std::move(list_.pop(pos));</div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;            <span class="keywordflow">if</span>(next.is_end())</div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;            {</div><div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;                <span class="comment">// &#39;pos&#39; was the last item in &#39;list_&#39;.  The bucket is now empty.</span></div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;                table_[buck_idx] = <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>();</div><div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;                <span class="keywordflow">return</span> std::make_pair(std::move(node), end());</div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;            }</div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;</div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> next_idx = iter_bucket_index(next); next_idx != buck_idx)</div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;            {</div><div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;                <span class="comment">// The const_iterator after &#39;bucket_head&#39; is in a different bucket.</span></div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;                <span class="comment">// &#39;pos&#39; was the last item in its bucket and the bucket is now empty.</span></div><div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;                <span class="comment">// Since we just invalidated all iterators to the element following</span></div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;                <span class="comment">// &#39;pos&#39;, we need to fix iterator in the bucket whose first element</span></div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;                <span class="comment">// was pointed to by next(pos).</span></div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;                table_[buck_idx] = <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>();</div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;                <span class="comment">// Fix the iterator we invalidated.</span></div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;                table_[next_idx] = next;</div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;            }</div><div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;            {</div><div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;                <span class="comment">// &#39;pos&#39; was *not* the last element in its bucket.  The iterator</span></div><div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;                <span class="comment">// stored in the bucket should automagically point to the next</span></div><div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;                <span class="comment">// item.  Nothing to fix.</span></div><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;                assert(table_[buck_idx] == next);</div><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;            }</div><div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;            <span class="keywordflow">return</span> std::make_pair(std::move(node), next); </div><div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;        }</div><div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;        {</div><div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;            <span class="comment">// &#39;pos&#39; is *not* the first item in its bucket.</span></div><div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;            <span class="keyword">auto</span> [node, next] = std::move(list_.pop(pos));</div><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;            <span class="keywordflow">if</span>(next.is_end())</div><div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;            {</div><div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;                <span class="comment">// &#39;pos&#39; was the last item in the whole list.  Nothing to fix.</span></div><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;                <span class="keywordflow">return</span> std::make_pair(std::move(node), end());</div><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;            }</div><div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;</div><div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> next_idx = iter_bucket_index(next); next_idx != buck_idx)</div><div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;            {</div><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;                <span class="comment">// &#39;pos&#39; was the last item in its bucket.  </span></div><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;                <span class="comment">// Since we just invalidated all iterators to the element following</span></div><div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;                <span class="comment">// &#39;pos&#39;, we need to fix iterator in the bucket whose first element</span></div><div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;                <span class="comment">// was pointed to by next(pos).</span></div><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;                table_[next_idx] = next;</div><div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;            }</div><div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;            {</div><div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;                <span class="comment">// &#39;pos&#39; was *not* the last element in its bucket.  The iterator</span></div><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;                <span class="comment">// stored in the bucket should automagically point to the next</span></div><div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;                <span class="comment">// item.  Nothing to fix.</span></div><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;                assert(table_[buck_idx] == next);</div><div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;            }</div><div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;            <span class="keywordflow">return</span> std::make_pair(std::move(node), next); </div><div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;        }</div><div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;    }</div><div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;</div><div class="line"><a name="l01776"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a9e29e8eb2ac4ec9e5d3b1da300b50290"> 1776</a></span>&#160;    <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> <a class="code" href="structte_1_1AnySet.html#a9e29e8eb2ac4ec9e5d3b1da300b50290">dup</a>(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos)<span class="keyword"> const</span></div><div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> pos-&gt;clone(); }</div><div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;</div><div class="line"><a name="l01791"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a2e24b473f4e5302c7bf6d501be97df51"> 1791</a></span>&#160;    std::pair&lt;iterator, node_handle&gt; <a class="code" href="structte_1_1AnySet.html#a2e24b473f4e5302c7bf6d501be97df51">push</a>(<a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>&amp;&amp; node)</div><div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;    {</div><div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;        <span class="keyword">auto</span> [pos, found] = find_position(make_key_info(*node));</div><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;        <span class="keywordflow">if</span>(found)</div><div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;            <span class="keywordflow">return</span> std::make_pair(pos.to_non_const(), std::move(node));</div><div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;        <a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a> ins_pos = safely_splice_at(pos, std::move(node));</div><div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;        <span class="keywordflow">return</span> std::make_pair(ins_pos, <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>(<span class="keyword">nullptr</span>));</div><div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;    }</div><div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;</div><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;    </div><div class="line"><a name="l01821"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ab7420d89b8635801e053854c862f40ce"> 1821</a></span>&#160;    std::tuple&lt;iterator, iterator, bool&gt; <a class="code" href="structte_1_1AnySet.html#ab7420d89b8635801e053854c862f40ce">splice</a>(<a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; other, <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos)</div><div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;    { <span class="keywordflow">return</span> splice_or_copy(std::move(other), pos); }</div><div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;</div><div class="line"><a name="l01842"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#ab598afce723f1e27452bab44f41410a1"> 1842</a></span>&#160;    std::pair&lt;iterator, iterator&gt; <a class="code" href="structte_1_1AnySet.html#ab598afce723f1e27452bab44f41410a1">splice</a>(<a class="code" href="structte_1_1AnySet.html">AnySet</a>&amp; other, <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> first, <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> last)</div><div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;    { <span class="keywordflow">return</span> splice_or_copy(std::move(other), first, last); }</div><div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;</div><div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, self_type&gt;&gt;&gt;</div><div class="line"><a name="l01872"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a305ff8b8218ab15ef6f04395ff298162"> 1872</a></span>&#160;    <span class="keyword">auto</span> <a class="code" href="structte_1_1AnySet.html#a305ff8b8218ab15ef6f04395ff298162">splice_or_copy</a>(T&amp;&amp; other, <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> first, <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> last)</div><div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;        -&gt; std::pair&lt;decltype(other.begin()), decltype(other.begin())&gt; </div><div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;    {</div><div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;        <span class="keywordflow">if</span>(first == last)</div><div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;            <span class="keywordflow">return</span> std::make_pair(first.to_non_const(), last.to_non_const());</div><div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;        preemptive_reserve(std::distance(first, last));</div><div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;        <span class="keyword">auto</span> pos = first;</div><div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div><div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;        <span class="keywordflow">do</span> {</div><div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;            done = (std::next(pos) == last);</div><div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;            std::tie(std::ignore, pos, std::ignore) = splice_or_copy(std::forward&lt;T&gt;(other), pos);</div><div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;        } <span class="keywordflow">while</span>(not done);</div><div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;        <span class="keywordflow">return</span> std::make_pair(first.to_non_const(), pos.to_non_const());</div><div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;    }</div><div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;</div><div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, self_type&gt;&gt;&gt;</div><div class="line"><a name="l01916"></a><span class="lineno"><a class="line" href="structte_1_1AnySet.html#a1ee90ef4d5c25620f52a1bcb1e7de9be"> 1916</a></span>&#160;    <span class="keyword">auto</span> <a class="code" href="structte_1_1AnySet.html#a1ee90ef4d5c25620f52a1bcb1e7de9be">splice_or_copy</a>(T&amp;&amp; other, <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos)</div><div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;        -&gt; std::tuple&lt;<a class="code" href="structte_1_1AnySet_1_1iterator.html">iterator</a>, decltype(other.begin()), <span class="keywordtype">bool</span>&gt;</div><div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;    {</div><div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;        <span class="keyword">using</span> tuple_t = std::tuple&lt;iterator, decltype(other.begin()), <span class="keywordtype">bool</span>&gt;;</div><div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;        assert(not pos.is_end());</div><div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;        <span class="keyword">auto</span> ki = make_key_info(*pos);</div><div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;        <span class="keyword">auto</span> [ins_pos_, found] = find_position(ki);</div><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;        <span class="keyword">auto</span> ins_pos = ins_pos_.to_non_const();</div><div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;        <span class="keywordflow">if</span>(found)</div><div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;            <span class="keywordflow">return</span> tuple_t(ins_pos, std::next(pos).to_non_const(), <span class="keyword">false</span>);</div><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;        <span class="keywordflow">if</span> constexpr(</div><div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;            std::is_rvalue_reference_v&lt;decltype(other)&gt;</div><div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;            and not std::is_const_v&lt;std::remove_reference_t&lt;decltype(other)&gt;&gt;</div><div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;        )</div><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;        {</div><div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;            <span class="keyword">auto</span> [node, next] = other.pop(pos);</div><div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;            <span class="keywordflow">try</span></div><div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;            {</div><div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;                assert(load_factor_satisfied());</div><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;                <span class="keywordflow">return</span> tuple_t(</div><div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;                    safely_splice_at(ins_pos, ki, std::move(node)), next.to_non_const(), true</div><div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;                );</div><div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;            }</div><div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;            <span class="keywordflow">catch</span>(...)</div><div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;            {</div><div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;                <span class="comment">// put back the node if didn&#39;t make it in</span></div><div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;                <span class="keywordflow">if</span>(node)</div><div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;                    other.unsafe_splice_at(pos, std::move(node));</div><div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;                <span class="keywordflow">throw</span>;</div><div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;            }</div><div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;        }</div><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;        {</div><div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;            assert(load_factor_satisfied());</div><div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;            <span class="keywordflow">return</span> tuple_t(</div><div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;                safely_splice_at(ins_pos, ki, other.dup(pos)), </div><div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;                std::next(pos).to_non_const(), </div><div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;                true</div><div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;            );</div><div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;        }</div><div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;    }</div><div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;</div><div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;</div><div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;</div><div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;    <span class="keywordtype">void</span> fix_table_after_move()</div><div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;    {</div><div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;        <span class="keywordflow">if</span>(size() &gt; 0u)</div><div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;            table_[iter_bucket_index(begin())] = begin();</div><div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;    }</div><div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;</div><div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;    <span class="keywordtype">float</span> load_factor(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> extra) <span class="keyword">const</span> noexcept</div><div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(size() + extra) / table_size(); }</div><div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;    </div><div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;    <span class="keywordtype">bool</span> load_factor_satisfied(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> extra = 0)<span class="keyword"> const</span></div><div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> load_factor(extra) &lt;= max_load_factor(); }</div><div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;</div><div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;    iterator safely_splice_at(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos, <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>&amp;&amp; node)</div><div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;    {</div><div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;        <span class="keywordflow">return</span> safely_splice_at(pos, make_key_info(*node), std::move(node));</div><div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;    }</div><div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;</div><div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;    iterator safely_splice_at(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos, <span class="keyword">const</span> KeyInfo&lt;Value&gt;&amp; ki, <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>&amp;&amp; node)</div><div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;    {</div><div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;        <span class="comment">// Insert the node, *then* check if a rehash is needed.  This optimizes for the case</span></div><div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;        <span class="comment">// where we don&#39;t rehash (which is almost certainly the common case) and doing it this </span></div><div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;        <span class="comment">// way results in simpler code.</span></div><div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;        iterator ins_pos = unsafe_splice_at(pos, ki, std::move(node));</div><div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;</div><div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;        <span class="keywordflow">if</span>(not load_factor_satisfied()) </div><div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;        {</div><div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;            <span class="comment">// However, we want rollback semantics if resizing the bucket table throws an exception.</span></div><div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;            <span class="comment">// Use the scope guard pattern instead of a try-catch-rethrow.  This lets the compiler possibly</span></div><div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;            <span class="comment">// optimize the guard out entirely if callers don&#39;t have an exception handler (many </span></div><div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;            <span class="comment">// implementations only propagate exceptions when there&#39;s a handler beneath the throw).</span></div><div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;            <span class="keyword">struct </span>RollbackScopeGuard {</div><div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;                <a class="code" href="structte_1_1AnySet.html">self_type</a>&amp; <span class="keyword">self</span>; <span class="comment">// *this</span></div><div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;                <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos; <span class="comment">// iterator to erase </span></div><div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;                <span class="keywordtype">bool</span> good = <span class="keyword">false</span>; <span class="comment">// whether we</span></div><div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;                </div><div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;                ~RollbackScopeGuard()</div><div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;                {</div><div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;                    <span class="comment">// If growing failed, erase the value we just inserted.</span></div><div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;                    <span class="comment">// This gives us rollback/commit semantics and only pessimizes</span></div><div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;                    <span class="comment">// the uncommon case.</span></div><div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;                    <span class="keywordflow">if</span>(not good) </div><div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;                        <span class="comment">// Control flow only reach here if an exception is thrown by &#39;grow_table&#39;.</span></div><div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;                        <span class="keyword">self</span>.erase(pos);</div><div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;                }</div><div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;            } guard{*<span class="keyword">this</span>, pos, <span class="keyword">false</span>};</div><div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;</div><div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;            <span class="comment">// Before we grow the table, save the address of the inserted node, we&#39;ll need it</span></div><div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;            <span class="comment">// to find the node again after rehashing.</span></div><div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;            <span class="keyword">const</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>* addr_save = std::addressof(*ins_pos);</div><div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;</div><div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;            grow_table(2 * table_size());</div><div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;</div><div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;            <span class="comment">// No exceptions thrown.</span></div><div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;            guard.good = <span class="keyword">true</span>;</div><div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;</div><div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;            <span class="comment">// the key landed somewhere else now, go find it to give the caller their iterator.</span></div><div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;            <span class="keyword">auto</span> buck_idx = bucket_index(ki.hash);</div><div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;            <span class="keyword">auto</span> buck_pos = table_[buck_idx];</div><div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;            assert(not buck_pos.is_null());</div><div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;            assert(not buck_pos.is_end());</div><div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;            <span class="keywordflow">while</span>(std::addressof(*buck_pos) != addr_save)</div><div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;            {</div><div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;                ++buck_pos;</div><div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;                assert(iter_bucket_index(buck_pos) == buck_idx);</div><div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;            }</div><div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;            <span class="keywordflow">return</span> buck_pos.to_non_const();</div><div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;        }</div><div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;        {</div><div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;            <span class="comment">// No rehash, just return ins_pos.</span></div><div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;            <span class="keywordflow">return</span> ins_pos;</div><div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;        }</div><div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;    }</div><div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;</div><div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;    iterator initialize_bucket(<span class="keyword">const</span> KeyInfo&lt;Value&gt;&amp; ki, <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>&amp;&amp; node)</div><div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;    {</div><div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;        assert(table_[ki.bucket].is_null());</div><div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;        <span class="keywordflow">return</span> table_[ki.bucket] = list_.push_back(std::move(node));</div><div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;    }</div><div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;</div><div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;    iterator unsafe_splice_at(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos, <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>&amp;&amp; node)</div><div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;    {</div><div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;        <span class="keywordflow">return</span> unsafe_splice_at(pos, make_key_info(*node), std::move(node));</div><div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;    }</div><div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;</div><div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;    iterator unsafe_splice_at(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos, <span class="keyword">const</span> KeyInfo&lt;Value&gt;&amp; ki, <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a>&amp;&amp; node)</div><div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;    {</div><div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;        <span class="keywordflow">if</span>(pos.is_null())</div><div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;            <span class="keywordflow">return</span> initialize_bucket(ki, std::move(node));</div><div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pos.is_end())</div><div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;            <span class="keywordflow">return</span> list_.splice(pos, std::move(node));</div><div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;</div><div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> buck_idx = iter_bucket_index(pos);</div><div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;        iterator ins_pos = list_.splice(pos, std::move(node));</div><div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;        <span class="keywordflow">if</span>(buck_idx != ki.bucket)</div><div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;        {</div><div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;            <span class="comment">// The iterator that we just inserted changed the value of an iterator </span></div><div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;            <span class="comment">// in another bucket.  The iterator whose value changed should now point </span></div><div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;            <span class="comment">// to the &#39;next&#39; of the node we just inserted.  Make it so.</span></div><div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;            <span class="keyword">auto</span> next_pos = std::next(ins_pos);</div><div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;            assert(iter_bucket_index(next_pos) == buck_idx);</div><div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;            table_[buck_idx] = next_pos;</div><div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;        }</div><div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;        <span class="keywordflow">return</span> ins_pos;</div><div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;    }</div><div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;</div><div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;    <span class="keywordtype">bool</span> insertion_compare(<span class="keyword">const</span> Value&amp; value, <span class="keyword">const</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>&amp; any_v)<span class="keyword"> const</span></div><div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> compare(value, any_v, get_key_equal()); }</div><div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;</div><div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;    <span class="keywordtype">bool</span> insertion_compare(<span class="keyword">const</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>&amp; any_v, <span class="keyword">const</span> Value&amp; value)<span class="keyword"> const</span></div><div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> compare(any_v, value, get_key_equal()); }</div><div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;</div><div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;    std::size_t get_hash_value(<span class="keyword">const</span> Value&amp; value)<span class="keyword"> const</span></div><div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;        <span class="keywordflow">if</span> constexpr(std::is_same_v&lt;Value, value_type&gt;)</div><div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;            <span class="keywordflow">return</span> value.hash;</div><div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;            <span class="keywordflow">return</span> get_hasher()(value);</div><div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;    }</div><div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;    </div><div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> iter_bucket_index(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> pos)<span class="keyword"> const</span></div><div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;        assert(not pos.is_end());</div><div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;        <span class="keywordflow">return</span> bucket_index(pos-&gt;hash);</div><div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;    }</div><div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;</div><div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;    KeyInfo&lt;Value&gt; make_key_info(<span class="keyword">const</span> Value&amp; val)<span class="keyword"> const</span></div><div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;        <span class="keywordflow">return</span> make_key_info(val, get_hash_value(val));</div><div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;    }</div><div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;</div><div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;    KeyInfo&lt;Value&gt; make_key_info(<span class="keyword">const</span> Value&amp; val, std::size_t hash_v)<span class="keyword"> const</span></div><div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;        <span class="keywordflow">return</span> KeyInfo&lt;Value&gt;{val, hash_v, bucket_index(hash_v)};</div><div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;    }</div><div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;</div><div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;    <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a> find_matching_value(<span class="keyword">const</span> Value&amp; value)<span class="keyword"> const</span></div><div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;        <span class="keyword">auto</span> ki = make_key_info(value);</div><div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;        <span class="keyword">auto</span> [pos, last] = get_bucket_start(ki);</div><div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;        <span class="keywordflow">if</span>(pos.is_null() or (not last.is_null()))</div><div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;            <span class="keywordflow">return</span> cend();</div><div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;</div><div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;        <span class="keywordflow">while</span>((not pos.is_end()) and (pos-&gt;hash == ki.hash))</div><div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;        {</div><div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;            <span class="keywordflow">if</span>(*pos == value)</div><div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>(pos);</div><div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;            ++pos;</div><div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;        }</div><div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;        <span class="keywordflow">return</span> cend();</div><div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;    }</div><div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;</div><div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class </span>... T&gt;</div><div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;    std::bitset&lt;<span class="keyword">sizeof</span>...(T)&gt; arg_insert(T&amp;&amp; ... args)</div><div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;    {</div><div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;        std::bitset&lt;<span class="keyword">sizeof</span>...(T)&gt; bs;</div><div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;        std::size_t pos = 0;</div><div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;        preemptive_reserve(<span class="keyword">sizeof</span>...(args));</div><div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;</div><div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;        <span class="comment">// set the ith bit if the ith arg was inserted</span></div><div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;        (bs.set(pos++, insert_impl&lt;false&gt;(std::forward&lt;T&gt;(args)).second) , ...);</div><div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;</div><div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;        assert(load_factor() &lt;= max_load_factor());</div><div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;        <span class="keywordflow">return</span> bs;</div><div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;    }</div><div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;</div><div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> It&gt;</div><div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> range_insert(It first, It last, std::input_iterator_tag)</div><div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;    {</div><div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> count = 0;</div><div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;        <span class="keywordflow">while</span>(first != last)</div><div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;            count += <span class="keyword">static_cast&lt;</span><a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a><span class="keyword">&gt;</span>(insert_impl&lt;true&gt;(*first++).second);</div><div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;        <span class="keywordflow">return</span> count;</div><div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;    }</div><div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;</div><div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;    template &lt;class It, class = std::enable_if_t&lt;std::is_copy_constructible_v&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;&gt;&gt;</div><div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> range_insert(It first, It last, std::forward_iterator_tag)</div><div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;    {</div><div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> count = 0;</div><div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;        preemptive_reserve(std::distance(first, last));</div><div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;        <span class="keywordflow">while</span>(first != last)</div><div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;            count += <span class="keyword">static_cast&lt;</span><a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a><span class="keyword">&gt;</span>(insert_impl&lt;false&gt;(*first++).second);</div><div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;        assert(load_factor() &lt;= max_load_factor());</div><div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;        <span class="keywordflow">return</span> count;</div><div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;    }</div><div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;</div><div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;    <span class="keywordtype">void</span> preemptive_reserve(std::size_t ins_count)</div><div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;    {</div><div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;        <span class="keyword">auto</span> new_count = size() + ins_count;</div><div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> new_table_size = table_size();</div><div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;        assert(new_table_size &gt; 0u);</div><div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;        <span class="keyword">auto</span> compute_new_load_factor = [&amp;](){</div><div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;            <span class="keywordflow">return</span> (static_cast&lt;double&gt;(new_count) / new_table_size);</div><div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;        };</div><div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;        <span class="keywordflow">while</span>(compute_new_load_factor() &gt; max_load_factor())</div><div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;            new_table_size *= 2;</div><div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;        <span class="keywordflow">if</span>(new_table_size &gt; table_size())</div><div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;            grow_table(new_table_size);</div><div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;    }</div><div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;</div><div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;    <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> CheckLoadFactor, <span class="keyword">class</span> T&gt;</div><div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;    std::pair&lt;iterator, bool&gt; insert_impl(T&amp;&amp; value)</div><div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;    {</div><div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;        <span class="keywordflow">return</span> insert_impl&lt;CheckLoadFactor&gt;(</div><div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;            std::forward&lt;T&gt;(value), make_key_info(value), nullptr</div><div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;        );</div><div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;    }</div><div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;    </div><div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;    <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> CheckLoadFactor, <span class="keyword">class</span> T&gt;</div><div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;    std::pair&lt;iterator, bool&gt; insert_impl(</div><div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;        T&amp;&amp; value,</div><div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;        <span class="keyword">const</span> KeyInfo&lt;std::decay_t&lt;T&gt;&gt;&amp; ki,</div><div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> existing = <span class="keyword">nullptr</span></div><div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;    )</div><div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;    {</div><div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;        <span class="keyword">using</span> ValueType = std::decay_t&lt;T&gt;;</div><div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;        iterator ins_pos;</div><div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;        <span class="keyword">auto</span> [pos, found] = find_position(ki);</div><div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;        </div><div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;        <span class="keywordflow">if</span>(not found)</div><div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;        {</div><div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;            <span class="comment">// if constexpr(std::is_copy_constructible_v&lt;ValueType&gt;)</span></div><div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;            <span class="keywordflow">if</span> constexpr(std::is_constructible_v&lt;ValueType, decltype(value)&gt;)</div><div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;            {</div><div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;                <span class="keywordflow">if</span>(not existing)</div><div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;                {</div><div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;                    existing = make_any_value&lt;std::decay_t&lt;T&gt;, HashFn, KeyEqual&gt;(</div><div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;                        ki.hash, std::forward&lt;T&gt;(value)</div><div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;                    );</div><div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;                }</div><div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;            }</div><div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;            {</div><div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;                assert(existing);</div><div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;            }</div><div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;</div><div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;            <span class="keywordflow">if</span> constexpr(CheckLoadFactor)</div><div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;                ins_pos = safely_splice_at(pos, ki, std::move(existing));</div><div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;                ins_pos = unsafe_splice_at(pos, ki, std::move(existing));</div><div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;            assert(not ins_pos.is_null());</div><div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;            assert(not ins_pos.is_end());</div><div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;        }</div><div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;        {</div><div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;            ins_pos = pos.to_non_const();</div><div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;        }</div><div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;        <span class="keywordflow">return</span> std::make_pair(ins_pos, not found);</div><div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;    }</div><div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;</div><div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;    <span class="keywordtype">void</span> shrink_table(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> new_size) noexcept</div><div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;    {</div><div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;        assert(new_size &lt; table_size());</div><div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;        <span class="comment">// new size must always be a power of two</span></div><div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;        assert((new_size &amp; (new_size - 1)) == 0u);</div><div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;</div><div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;        table_.assign(new_size, iterator());</div><div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;</div><div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;        <a class="code" href="classte_1_1detail_1_1AnyList.html">list_type</a> tmp = std::move(list_);</div><div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;        assert(size() == 0u);</div><div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> node{<span class="keyword">nullptr</span>};</div><div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;        <span class="keywordflow">while</span>(not tmp.empty())</div><div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;        {</div><div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;            node = std::move(tmp.pop(tmp.begin()).first);</div><div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;            node = std::move(push(std::move(node)).second);</div><div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;            assert(not static_cast&lt;bool&gt;(node));</div><div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;        }</div><div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;        assert(tmp.empty());</div><div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;    }</div><div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;</div><div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;    <span class="keywordtype">void</span> grow_table(<a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> new_size)</div><div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;    {</div><div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;        assert(new_size &gt; table_size());</div><div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;        <span class="comment">// new size must always be a power of two</span></div><div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;        assert((new_size &amp; (new_size - 1)) == 0u);</div><div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;        table_.assign(new_size, iterator());</div><div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;        <a class="code" href="classte_1_1detail_1_1AnyList.html">list_type</a> tmp = std::move(list_);</div><div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;        assert(size() == 0u);</div><div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;        <a class="code" href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">node_handle</a> node{<span class="keyword">nullptr</span>};</div><div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;        <span class="keywordflow">while</span>(not tmp.empty())</div><div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;        {</div><div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;            node = std::move(tmp.pop(tmp.begin()).first);</div><div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;            node = std::move(push(std::move(node)).second);</div><div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;            assert(not static_cast&lt;bool&gt;(node));</div><div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;        }</div><div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;        assert(tmp.empty());</div><div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;    }</div><div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;</div><div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;    std::pair&lt;const_iterator, bool&gt; find_position(<span class="keyword">const</span> KeyInfo&lt;Value&gt;&amp; ki)<span class="keyword"> const</span></div><div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> find_position(ki, get_key_equal()); }</div><div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;</div><div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> Comp&gt;</div><div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;    std::pair&lt;const_iterator, bool&gt; find_position(<span class="keyword">const</span> KeyInfo&lt;Value&gt;&amp; ki, Comp comp)<span class="keyword"> const</span></div><div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;        <span class="keywordflow">if</span>(<span class="keyword">auto</span> [pos, last] = get_bucket_start(ki); pos.is_null() and last.is_null())</div><div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;        {</div><div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;            <span class="comment">// Bucket is empty, return null iterator.</span></div><div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;            <span class="keywordflow">return</span> std::make_pair(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>(), <span class="keyword">false</span>);</div><div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;        }</div><div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(last.is_null())</div><div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;        {</div><div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;            assert(pos-&gt;hash &gt;= ki.hash);</div><div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;            <span class="keywordflow">for</span>(; (not pos.is_end()) and pos-&gt;hash == ki.hash; ++pos)</div><div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;            {</div><div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;                <span class="keywordflow">if</span>(compare(ki.value, *pos, comp))</div><div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;                    <span class="comment">// found a match</span></div><div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;                    <span class="keywordflow">return</span> std::make_pair(pos, <span class="keyword">true</span>);</div><div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;            }</div><div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;            <span class="comment">// No match, return const_iterator to first element whose hash is</span></div><div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;            <span class="comment">// greater than ki&#39;s hash, or the end of the list, which ever comes</span></div><div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;            <span class="comment">// first.</span></div><div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;            <span class="keywordflow">return</span> std::make_pair(pos, <span class="keyword">false</span>);</div><div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;        }</div><div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;        {</div><div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;            assert(not pos.is_null());</div><div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;            assert(last == cend() or iter_bucket_index(last) != ki.bucket);</div><div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;            <span class="comment">// No match, return end of the bucket.</span></div><div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;            <span class="keywordflow">return</span> std::make_pair(last, <span class="keyword">false</span>);</div><div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;        }</div><div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;    }</div><div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;</div><div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div><div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;    std::pair&lt;const_iterator, const_iterator&gt; get_bucket_start(<span class="keyword">const</span> KeyInfo&lt;Value&gt;&amp; ki)<span class="keyword"> const</span></div><div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;<span class="keyword">    </span>{</div><div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;        <span class="keyword">auto</span> first = table_[ki.bucket];</div><div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;        <span class="keywordflow">if</span>(first.is_null())</div><div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;            <span class="comment">// two &#39;null&#39; const_iterators</span></div><div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;            <span class="keywordflow">return</span> std::make_pair(<a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>(), <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>()); </div><div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;        assert(not first.is_end());</div><div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;        <span class="keyword">auto</span> pos = first;</div><div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;        std::size_t pos_hash = pos-&gt;hash;</div><div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;        <span class="keywordflow">do</span> {</div><div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;            <span class="keywordflow">if</span>(pos_hash &gt;= ki.hash)</div><div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;                <span class="keywordflow">return</span> std::make_pair(pos, <a class="code" href="structte_1_1AnySet_1_1const__iterator.html">const_iterator</a>());</div><div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;            ++pos;</div><div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;            <span class="keywordflow">if</span>(pos.is_end())</div><div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;            pos_hash = pos-&gt;hash;</div><div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;        } <span class="keywordflow">while</span>(bucket_index(pos_hash) == ki.bucket);</div><div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;        <span class="keywordflow">return</span> std::make_pair(first, pos);</div><div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;    }</div><div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;</div><div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> table_size()<span class="keyword"> const</span></div><div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> table_.size(); }</div><div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;</div><div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> get_mask()<span class="keyword"> const</span></div><div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> table_size() - 1; }</div><div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;</div><div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;    <a class="code" href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">size_type</a> bucket_index(std::size_t hash)<span class="keyword"> const</span></div><div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> hash &amp; get_mask(); }</div><div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;</div><div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;    <span class="keywordtype">bool</span> equal_values(<span class="keyword">const</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>&amp; left, <span class="keyword">const</span> <a class="code" href="structte_1_1AnyValue.html">value_type</a>&amp; right)<span class="keyword"> const</span></div><div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;<span class="keyword">    </span>{ <span class="keywordflow">return</span> left.compare_to(right, get_key_equal()); }</div><div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;</div><div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;    <span class="comment">// functions to access the hasher and comparator</span></div><div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;    <a class="code" href="structte_1_1CompressedPair.html">pair_type</a>&amp; as_pair() &amp;</div><div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="structte_1_1CompressedPair.html">pair_type</a>&amp;<span class="keyword">&gt;</span>(*this); }</div><div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;</div><div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;    <a class="code" href="structte_1_1CompressedPair.html">pair_type</a>&amp;&amp; as_pair() &amp;&amp;</div><div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="structte_1_1CompressedPair.html">pair_type</a>&amp;&amp;<span class="keyword">&gt;</span>(*this); }</div><div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;</div><div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;    <span class="keyword">const</span> <a class="code" href="structte_1_1CompressedPair.html">pair_type</a>&amp; as_pair() <span class="keyword">const</span> &amp;</div><div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="structte_1_1CompressedPair.html">pair_type</a>&amp;<span class="keyword">&gt;</span>(*this); }</div><div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;</div><div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;    <span class="keyword">const</span> <a class="code" href="structte_1_1CompressedPair.html">pair_type</a>&amp;&amp; as_pair() <span class="keyword">const</span> &amp;&amp;</div><div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="structte_1_1CompressedPair.html">pair_type</a>&amp;&amp;<span class="keyword">&gt;</span>(*this); }</div><div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;</div><div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;    HashFn&amp; get_hasher() &amp;</div><div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;    { <span class="keywordflow">return</span> as_pair().first(); }</div><div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;</div><div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;    HashFn&amp;&amp; get_hasher() &amp;&amp;</div><div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;    { <span class="keywordflow">return</span> std::move(std::move(as_pair()).first()); }</div><div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;</div><div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;    <span class="keyword">const</span> HashFn&amp; get_hasher() <span class="keyword">const</span> &amp;</div><div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;    { <span class="keywordflow">return</span> as_pair().first(); }</div><div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;</div><div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;    <span class="keyword">const</span> HashFn&amp;&amp; get_hasher() <span class="keyword">const</span> &amp;&amp;</div><div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;    { <span class="keywordflow">return</span> std::move(std::move(as_pair()).first()); }</div><div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;</div><div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;    KeyEqual&amp; get_key_equal() &amp;</div><div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;    { <span class="keywordflow">return</span> as_pair().second(); }</div><div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;</div><div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;    KeyEqual&amp;&amp; get_key_equal() &amp;&amp;</div><div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;    { <span class="keywordflow">return</span> std::move(std::move(as_pair()).second()); }</div><div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;</div><div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;    <span class="keyword">const</span> KeyEqual&amp; get_key_equal() <span class="keyword">const</span> &amp;</div><div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;    { <span class="keywordflow">return</span> as_pair().second(); }</div><div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;</div><div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;    <span class="keyword">const</span> KeyEqual&amp;&amp; get_key_equal() <span class="keyword">const</span> &amp;&amp;</div><div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;    { <span class="keywordflow">return</span> std::move(std::move(as_pair()).second()); }</div><div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;</div><div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;    <a class="code" href="classte_1_1detail_1_1AnyList.html">list_type</a> list_;</div><div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;    vector_type table_;</div><div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;    <span class="keywordtype">float</span> max_load_factor_{1.0};</div><div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;};</div><div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;</div><div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;</div><div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;</div><div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;</div><div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;} <span class="comment">/* namespace te */</span>    </div><div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;</div><div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;<span class="preprocessor">#endif </span><span class="comment">/* ANY_SET_H */</span><span class="preprocessor"></span></div><div class="ttc" id="structte_1_1AnySet_1_1const__iterator_html"><div class="ttname"><a href="structte_1_1AnySet_1_1const__iterator.html">te::AnySet::const_iterator</a></div><div class="ttdoc">Forward iterator type returned from const operations on AnySet instances. </div><div class="ttdef"><b>Definition:</b> AnySet.h:149</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a42cffd4ef597d50514bd84509c4ddb9a"><div class="ttname"><a href="structte_1_1AnySet.html#a42cffd4ef597d50514bd84509c4ddb9a">te::AnySet::update</a></div><div class="ttdeci">AnySet &amp; update(AnySet &amp;&amp;other)</div><div class="ttdoc">Moves elements from other into the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1202</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a6a64b737fb06974c4658dff89717f252"><div class="ttname"><a href="structte_1_1AnySet.html#a6a64b737fb06974c4658dff89717f252">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(size_type bucket_count, const Allocator &amp;alloc)</div><div class="ttdoc">Construct an empty AnySet instance. Sets max_load_factor() to 1.0. </div><div class="ttdef"><b>Definition:</b> AnySet.h:378</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a0366d2d6867776b8ebfacaa167b4a5b0"><div class="ttname"><a href="structte_1_1AnySet.html#a0366d2d6867776b8ebfacaa167b4a5b0">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(std::tuple&lt; T ... &gt; &amp;&amp;tup, size_type bucket_count, const Allocator &amp;alloc)</div><div class="ttdoc">Construct an AnySet with the contents of the tuple tup. Sets max_load_factor() to 1...</div><div class="ttdef"><b>Definition:</b> AnySet.h:683</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a8f28f327d868e6c6cbccdd6eedad636e"><div class="ttname"><a href="structte_1_1AnySet.html#a8f28f327d868e6c6cbccdd6eedad636e">te::AnySet::const_local_iterator</a></div><div class="ttdeci">BucketIterator&lt; true &gt; const_local_iterator</div><div class="ttdoc">Const iterator type suitable for traversal through an individual bucket. </div><div class="ttdef"><b>Definition:</b> AnySet.h:320</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a572260b03bc8d5d23eb71f0c0e6193d0"><div class="ttname"><a href="structte_1_1AnySet.html#a572260b03bc8d5d23eb71f0c0e6193d0">te::AnySet::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdoc">Pointer to AnyValue. </div><div class="ttdef"><b>Definition:</b> AnySet.h:222</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a842f26f8ec56caf35806a2345a1ec70f"><div class="ttname"><a href="structte_1_1AnySet.html#a842f26f8ec56caf35806a2345a1ec70f">te::AnySet::equal_range</a></div><div class="ttdeci">std::pair&lt; const_iterator, const_iterator &gt; equal_range(const T &amp;value) const</div><div class="ttdoc">Obtain a const_iterator range to the elements that have the same type as, and compares equal to the v...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1283</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a2a15e80792ba9325429a42bbe2325e73"><div class="ttname"><a href="structte_1_1AnySet.html#a2a15e80792ba9325429a42bbe2325e73">te::AnySet::value_type</a></div><div class="ttdeci">AnyValue&lt; HashFn, KeyEqual &gt; value_type</div><div class="ttdoc">AnyValue. </div><div class="ttdef"><b>Definition:</b> AnySet.h:204</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a8d67e0b2dc842b7f6b858b974b694e4f"><div class="ttname"><a href="structte_1_1AnySet.html#a8d67e0b2dc842b7f6b858b974b694e4f">te::AnySet::hasher</a></div><div class="ttdeci">HashFn hasher</div><div class="ttdoc">Hash function type. </div><div class="ttdef"><b>Definition:</b> AnySet.h:212</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a6f4e76a019d6e5e20c66ef9c32d6b3ee"><div class="ttname"><a href="structte_1_1AnySet.html#a6f4e76a019d6e5e20c66ef9c32d6b3ee">te::AnySet::end</a></div><div class="ttdeci">const_iterator end() const</div><div class="ttdoc">Get a past-the-end const_iterator for this set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:810</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a4f779a63cfdc23f956c4a969fe2787f1"><div class="ttname"><a href="structte_1_1AnySet.html#a4f779a63cfdc23f956c4a969fe2787f1">te::AnySet::count</a></div><div class="ttdeci">size_type count(const T &amp;value) const</div><div class="ttdoc">Returns the number of elements with a value that have the same type as, and compare equal to the valu...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1233</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a70003fbdad1535a8ee15fba0b13d670b"><div class="ttname"><a href="structte_1_1AnySet.html#a70003fbdad1535a8ee15fba0b13d670b">te::AnySet::const_pointer</a></div><div class="ttdeci">const value_type * const_pointer</div><div class="ttdoc">Pointer to const AnyValue. </div><div class="ttdef"><b>Definition:</b> AnySet.h:224</div></div>
<div class="ttc" id="structte_1_1AnySet_1_1iterator_html"><div class="ttname"><a href="structte_1_1AnySet_1_1iterator.html">te::AnySet::iterator</a></div><div class="ttdoc">Forward iterator type returned from non-const operations on AnySet instances. </div><div class="ttdef"><b>Definition:</b> AnySet.h:110</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a9b1df747c2198efd5efe5ba16bfb314d"><div class="ttname"><a href="structte_1_1AnySet.html#a9b1df747c2198efd5efe5ba16bfb314d">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(InputIt first, InputIt last, size_type bucket_count, const HashFn &amp;hash, const Allocator &amp;alloc)</div><div class="ttdoc">Construct an AnySet instance from the range [first, last). Sets max_load_factor() to 1...</div><div class="ttdef"><b>Definition:</b> AnySet.h:462</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a8ca85fcaf35763f2339e77bbf93f505e"><div class="ttname"><a href="structte_1_1AnySet.html#a8ca85fcaf35763f2339e77bbf93f505e">te::AnySet::max_size</a></div><div class="ttdeci">bool max_size() const noexcept</div><div class="ttdoc">Get the maximum number of elements the container is able to hold due to system or library implementat...</div><div class="ttdef"><b>Definition:</b> AnySet.h:850</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a09f98db8233ff48a60d035be2fdcdf8f"><div class="ttname"><a href="structte_1_1AnySet.html#a09f98db8233ff48a60d035be2fdcdf8f">te::AnySet::contains_value</a></div><div class="ttdeci">bool contains_value(const value_type &amp;any_v) const</div><div class="ttdoc">Check if this contains the same value as another set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1321</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a9e29e8eb2ac4ec9e5d3b1da300b50290"><div class="ttname"><a href="structte_1_1AnySet.html#a9e29e8eb2ac4ec9e5d3b1da300b50290">te::AnySet::dup</a></div><div class="ttdeci">node_handle dup(const_iterator pos) const</div><div class="ttdoc">Copy and return the element at the position pointed to by pos. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1776</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a2bb9858e05bfa98608ce5f5dedcffb89"><div class="ttname"><a href="structte_1_1AnySet.html#a2bb9858e05bfa98608ce5f5dedcffb89">te::AnySet::insert</a></div><div class="ttdeci">size_type insert(std::initializer_list&lt; T &gt; ilist)</div><div class="ttdoc">Inserts elements from the list ilist that do not already exist in the set. If multiple elements in th...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1057</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a2e24b473f4e5302c7bf6d501be97df51"><div class="ttname"><a href="structte_1_1AnySet.html#a2e24b473f4e5302c7bf6d501be97df51">te::AnySet::push</a></div><div class="ttdeci">std::pair&lt; iterator, node_handle &gt; push(node_handle &amp;&amp;node)</div><div class="ttdoc">Insert the value pointed to by node to this. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1791</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a4c2cffe66078db7aa7916cdac9badfc6"><div class="ttname"><a href="structte_1_1AnySet.html#a4c2cffe66078db7aa7916cdac9badfc6">te::AnySet::node_handle</a></div><div class="ttdeci">std::unique_ptr&lt; value_type &gt; node_handle</div><div class="ttdef"><b>Definition:</b> AnySet.h:227</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a88d77aa672a65bf4adf8f7811ea8180b"><div class="ttname"><a href="structte_1_1AnySet.html#a88d77aa672a65bf4adf8f7811ea8180b">te::AnySet::begin</a></div><div class="ttdeci">const_iterator begin() const</div><div class="ttdoc">Get a const_iterator to the first element in the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:786</div></div>
<div class="ttc" id="structte_1_1AnySet_html_abd1f7f079a1a7fd7b7225f7a2fcb053c"><div class="ttname"><a href="structte_1_1AnySet.html#abd1f7f079a1a7fd7b7225f7a2fcb053c">te::AnySet::contains_eq</a></div><div class="ttdeci">bool contains_eq(const T &amp;value) const</div><div class="ttdoc">Check if this contains value. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1362</div></div>
<div class="ttc" id="structte_1_1AnySet_html_af5963685181390d0b2730e401a38998c"><div class="ttname"><a href="structte_1_1AnySet.html#af5963685181390d0b2730e401a38998c">te::AnySet::insert</a></div><div class="ttdeci">std::pair&lt; iterator, bool &gt; insert([[maybe_unused]] const_iterator hint, T &amp;&amp;value)</div><div class="ttdoc">Inserts an element into the set, if the set doesn&amp;#39;t already contain an element with an equivalent val...</div><div class="ttdef"><b>Definition:</b> AnySet.h:972</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a08dab7ac900042f7066c1ffa0b3c5375"><div class="ttname"><a href="structte_1_1AnySet.html#a08dab7ac900042f7066c1ffa0b3c5375">te::AnySet::reserve</a></div><div class="ttdeci">void reserve(size_type count)</div><div class="ttdoc">Sets the number of buckets to the number needed to accomodate at least count elements without exceedi...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1573</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a074e520f91cc54b3df3d1278c9944367"><div class="ttname"><a href="structte_1_1AnySet.html#a074e520f91cc54b3df3d1278c9944367">te::AnySet::swap</a></div><div class="ttdeci">friend void swap(AnySet &amp;left, AnySet &amp;right)</div><div class="ttdoc">Calls left.swap(right). </div><div class="ttdef"><b>Definition:</b> AnySet.h:1618</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a5ae18a17ec71db70fe41cd44d2b95962"><div class="ttname"><a href="structte_1_1AnySet.html#a5ae18a17ec71db70fe41cd44d2b95962">te::AnySet::end</a></div><div class="ttdeci">local_iterator end(size_type buck)</div><div class="ttdoc">Get a local_iterator to the element one past the least element in the bucket at index buck...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1439</div></div>
<div class="ttc" id="structte_1_1AnySet_html_aa82c525d87429e9586026c549d5fca34"><div class="ttname"><a href="structte_1_1AnySet.html#aa82c525d87429e9586026c549d5fca34">te::AnySet::size</a></div><div class="ttdeci">size_type size() const noexcept</div><div class="ttdoc">Gets the number of elements in the set, i.e. std::distance(begin(), end()). </div><div class="ttdef"><b>Definition:</b> AnySet.h:840</div></div>
<div class="ttc" id="structte_1_1detail_1_1is__iterator_html"><div class="ttname"><a href="structte_1_1detail_1_1is__iterator.html">te::detail::is_iterator</a></div><div class="ttdef"><b>Definition:</b> AnySet.h:33</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a60ea6c78bad173c6f63152992efa364a"><div class="ttname"><a href="structte_1_1AnySet.html#a60ea6c78bad173c6f63152992efa364a">te::AnySet::cend</a></div><div class="ttdeci">const_iterator cend() const</div><div class="ttdoc">Get a past-the-end const_iterator for this set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:802</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ae1714daaedbc435c19d0bd94320a3d15"><div class="ttname"><a href="structte_1_1AnySet.html#ae1714daaedbc435c19d0bd94320a3d15">te::AnySet::emplace</a></div><div class="ttdeci">std::pair&lt; iterator, bool &gt; emplace(Args &amp;&amp;... args)</div><div class="ttdoc">Inserts a new element into the container constructed in-place with the given args if there is no elem...</div><div class="ttdef"><b>Definition:</b> AnySet.h:892</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ac690ea857e56a70502d58aaf928e684e"><div class="ttname"><a href="structte_1_1AnySet.html#ac690ea857e56a70502d58aaf928e684e">te::AnySet::rehash</a></div><div class="ttdeci">void rehash(size_type nbuckets)</div><div class="ttdoc">Sets the number of buckets to the smallest possible value that is at least as large as nbuckets and r...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1534</div></div>
<div class="ttc" id="structte_1_1AnySet_html_af06734ed66e5a868809cbe92563e3a57"><div class="ttname"><a href="structte_1_1AnySet.html#af06734ed66e5a868809cbe92563e3a57">te::AnySet::bucket_count</a></div><div class="ttdeci">size_type bucket_count() const noexcept</div><div class="ttdoc">Get the number of buckets in the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1447</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a0ebc7157c6f105886de8e40fc0c3d9ad"><div class="ttname"><a href="structte_1_1AnySet.html#a0ebc7157c6f105886de8e40fc0c3d9ad">te::AnySet::reference</a></div><div class="ttdeci">value_type &amp; reference</div><div class="ttdoc">Reference to AnyValue. </div><div class="ttdef"><b>Definition:</b> AnySet.h:218</div></div>
<div class="ttc" id="structte_1_1AnySet_html_aadd6af9b081ad61a07e81090334614e2"><div class="ttname"><a href="structte_1_1AnySet.html#aadd6af9b081ad61a07e81090334614e2">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(std::tuple&lt; T ... &gt; &amp;&amp;tup, size_type bucket_count, const HashFn &amp;hash, const Allocator &amp;alloc)</div><div class="ttdoc">Construct an AnySet with the contents of the tuple tup. Sets max_load_factor() to 1...</div><div class="ttdef"><b>Definition:</b> AnySet.h:706</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a2547dfd6591204e184ed9a41a8119f99"><div class="ttname"><a href="structte_1_1AnySet.html#a2547dfd6591204e184ed9a41a8119f99">te::AnySet::cend</a></div><div class="ttdeci">const_local_iterator cend(size_type buck) const</div><div class="ttdoc">Get a const_local_iterator to the element one past the least element in the bucket at index buck...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1412</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a9d45dba54805315e0c4affc8ee6178d4"><div class="ttname"><a href="structte_1_1AnySet.html#a9d45dba54805315e0c4affc8ee6178d4">te::AnySet::max_bucket_count</a></div><div class="ttdeci">size_type max_bucket_count() const noexcept</div><div class="ttdoc">Get the maximum possible number of buckets in the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1455</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a9c6c0e28fee9b4a3f8ea81e2bd55e28b"><div class="ttname"><a href="structte_1_1AnySet.html#a9c6c0e28fee9b4a3f8ea81e2bd55e28b">te::AnySet::difference_type</a></div><div class="ttdeci">typename vector_type::difference_type difference_type</div><div class="ttdoc">Difference type. </div><div class="ttdef"><b>Definition:</b> AnySet.h:208</div></div>
<div class="ttc" id="classte_1_1detail_1_1AnyList_html"><div class="ttname"><a href="classte_1_1detail_1_1AnyList.html">te::detail::AnyList&lt; HashFn, KeyEqual &gt;</a></div></div>
<div class="ttc" id="structte_1_1AnySet_html_a08203fd19a36ef68255105b86542eb5b"><div class="ttname"><a href="structte_1_1AnySet.html#a08203fd19a36ef68255105b86542eb5b">te::AnySet::bucket_size</a></div><div class="ttdeci">size_type bucket_size(size_type buck) const</div><div class="ttdoc">Get the number of elements in the bucket at index buck. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1470</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a226874c61eb1eb38eee1f2ce0ab990a4"><div class="ttname"><a href="structte_1_1AnySet.html#a226874c61eb1eb38eee1f2ce0ab990a4">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(AnySet &amp;&amp;other, const Allocator &amp;alloc)</div><div class="ttdoc">Move constructs an AnySet instance from other. Constructs the set with the copy of the contents of ot...</div><div class="ttdef"><b>Definition:</b> AnySet.h:533</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a9c62381e07490eedda0fe18bf0f70ec2"><div class="ttname"><a href="structte_1_1AnySet.html#a9c62381e07490eedda0fe18bf0f70ec2">te::AnySet::end</a></div><div class="ttdeci">const_local_iterator end(size_type buck) const</div><div class="ttdoc">Get a const_local_iterator to the element one past the least element in the bucket at index buck...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1427</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a8e098e80fdf2b2192319ff76d601a1c3"><div class="ttname"><a href="structte_1_1AnySet.html#a8e098e80fdf2b2192319ff76d601a1c3">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(InputIt first, InputIt last, size_type bucket_count, const Allocator &amp;alloc)</div><div class="ttdoc">Construct an AnySet instance from the range [first, last). Sets max_load_factor() to 1...</div><div class="ttdef"><b>Definition:</b> AnySet.h:437</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a393e3a7a552f2d5cda17ee0bfa0a251e"><div class="ttname"><a href="structte_1_1AnySet.html#a393e3a7a552f2d5cda17ee0bfa0a251e">te::AnySet::empty</a></div><div class="ttdeci">bool empty() const noexcept</div><div class="ttdoc">Checks if the set has no elements, i.e. whether begin() == end(). </div><div class="ttdef"><b>Definition:</b> AnySet.h:832</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a65383e7f9deaaa338bf4a016a7106f72"><div class="ttname"><a href="structte_1_1AnySet.html#a65383e7f9deaaa338bf4a016a7106f72">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(AnySet &amp;&amp;other)</div><div class="ttdoc">Copy constructs an AnySet instance from other. Constructs the set with the copy of the contents of ot...</div><div class="ttdef"><b>Definition:</b> AnySet.h:552</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ab4e3a32bb198fb9a4de9a8917c1123f2"><div class="ttname"><a href="structte_1_1AnySet.html#ab4e3a32bb198fb9a4de9a8917c1123f2">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(InputIt first, InputIt last, size_type bucket_count=0, const HashFn &amp;hash=HashFn(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</div><div class="ttdoc">Construct an AnySet instance from the range [first, last). Sets max_load_factor() to 1...</div><div class="ttdef"><b>Definition:</b> AnySet.h:411</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a58b7e99fd9f0725a1874533f519c3ff1"><div class="ttname"><a href="structte_1_1AnySet.html#a58b7e99fd9f0725a1874533f519c3ff1">te::AnySet::key_eq</a></div><div class="ttdeci">key_equal key_eq() const</div><div class="ttdoc">Get a copy of the equality comparison function. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1596</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a4573f5334af88c606b3f73da6c6c0916"><div class="ttname"><a href="structte_1_1AnySet.html#a4573f5334af88c606b3f73da6c6c0916">te::AnySet::cbegin</a></div><div class="ttdeci">const_iterator cbegin() const</div><div class="ttdoc">Get a const_iterator to the first element in the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:778</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a158e154a3d03b13e4a035342bfe70569"><div class="ttname"><a href="structte_1_1AnySet.html#a158e154a3d03b13e4a035342bfe70569">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(size_type bucket_count, const HashFn &amp;hash, const Allocator &amp;alloc)</div><div class="ttdoc">Construct an empty AnySet instance. Sets max_load_factor() to 1.0. </div><div class="ttdef"><b>Definition:</b> AnySet.h:390</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a305ff8b8218ab15ef6f04395ff298162"><div class="ttname"><a href="structte_1_1AnySet.html#a305ff8b8218ab15ef6f04395ff298162">te::AnySet::splice_or_copy</a></div><div class="ttdeci">auto splice_or_copy(T &amp;&amp;other, const_iterator first, const_iterator last) -&gt; std::pair&lt; decltype(other.begin()), decltype(other.begin())&gt;</div><div class="ttdoc">Copies or moves the elements in the range [first, last) from other into this. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1872</div></div>
<div class="ttc" id="namespacete_html"><div class="ttname"><a href="namespacete.html">te</a></div><div class="ttdef"><b>Definition:</b> SetOperations.h:7</div></div>
<div class="ttc" id="structte_1_1CompressedPair_html"><div class="ttname"><a href="structte_1_1CompressedPair.html">te::CompressedPair</a></div><div class="ttdef"><b>Definition:</b> CompressedPair.h:41</div></div>
<div class="ttc" id="structte_1_1AnySet_html_acf3ff8ce9e70828b4240a67129eb5e83"><div class="ttname"><a href="structte_1_1AnySet.html#acf3ff8ce9e70828b4240a67129eb5e83">te::AnySet::operator=</a></div><div class="ttdeci">AnySet &amp; operator=(AnySet &amp;&amp;other) noexcept(std::is_nothrow_move_assignable_v&lt; vector_type &gt;)</div><div class="ttdoc">Move assigns the contents of this AnySet instance from the contents of other. Moves the load factor...</div><div class="ttdef"><b>Definition:</b> AnySet.h:744</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ab598afce723f1e27452bab44f41410a1"><div class="ttname"><a href="structte_1_1AnySet.html#ab598afce723f1e27452bab44f41410a1">te::AnySet::splice</a></div><div class="ttdeci">std::pair&lt; iterator, iterator &gt; splice(AnySet &amp;other, const_iterator first, const_iterator last)</div><div class="ttdoc">Moves the elements in the range [first, last) from other into this. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1842</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a966efeede2c85ea0e11b7af0366119ec"><div class="ttname"><a href="structte_1_1AnySet.html#a966efeede2c85ea0e11b7af0366119ec">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(size_type bucket_count, const HashFn &amp;hash=HashFn(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</div><div class="ttdoc">Construct an empty AnySet instance. Sets max_load_factor() to 1.0. </div><div class="ttdef"><b>Definition:</b> AnySet.h:361</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a5106dea17f03564a1450f9649ba6741a"><div class="ttname"><a href="structte_1_1AnySet.html#a5106dea17f03564a1450f9649ba6741a">te::AnySet::max_load_factor</a></div><div class="ttdeci">float max_load_factor() const noexcept</div><div class="ttdoc">Get the maximum allowable load factor for the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1512</div></div>
<div class="ttc" id="structte_1_1AnySet_html_aaf7d6344803cdd2c500fc69195caafa5"><div class="ttname"><a href="structte_1_1AnySet.html#aaf7d6344803cdd2c500fc69195caafa5">te::AnySet::insert</a></div><div class="ttdeci">std::bitset&lt; 2ull+sizeof...(V)&gt; insert(T &amp;&amp;first, U &amp;&amp;second, V &amp;&amp;... args)</div><div class="ttdoc">Inserts args if they do not already exist in the set. If multiple values in args have the same type a...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1031</div></div>
<div class="ttc" id="structte_1_1AnySet_html_aa168fffe9f11ad2ebde217740baa1cbf"><div class="ttname"><a href="structte_1_1AnySet.html#aa168fffe9f11ad2ebde217740baa1cbf">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(std::initializer_list&lt; T &gt; ilist, size_type bucket_count, const HashFn &amp;hash, const Allocator &amp;alloc)</div><div class="ttdoc">Construct an AnySet with the contents of the initializer list ilist. Same as AnySet(init.begin(), init.end()). Sets max_load_factor() to 1.0. If multiple elements in the list compare equivalent, only the first encountered is inserted. </div><div class="ttdef"><b>Definition:</b> AnySet.h:628</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a1a526cfab6e3e4dd20607793aa346c14"><div class="ttname"><a href="structte_1_1AnySet.html#a1a526cfab6e3e4dd20607793aa346c14">te::AnySet::equal_range</a></div><div class="ttdeci">std::pair&lt; iterator, iterator &gt; equal_range(const T &amp;value)</div><div class="ttdoc">Obtain an iterator range to the elements that have the same type as, and compares equal to the value...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1303</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a3cf95080869e749c8e06cf7f4f9130a4"><div class="ttname"><a href="structte_1_1AnySet.html#a3cf95080869e749c8e06cf7f4f9130a4">te::AnySet::clear</a></div><div class="ttdeci">void clear() noexcept</div><div class="ttdoc">Removes all elements from the container. Invalidates any references, pointers, or iterators referring...</div><div class="ttdef"><b>Definition:</b> AnySet.h:862</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ae5e4dcb2691ff7bca954aa1b6e8a7f3d"><div class="ttname"><a href="structte_1_1AnySet.html#ae5e4dcb2691ff7bca954aa1b6e8a7f3d">te::AnySet::emplace_hint</a></div><div class="ttdeci">std::pair&lt; iterator, bool &gt; emplace_hint([[maybe_unused]] const_iterator hint, Args &amp;&amp;... args)</div><div class="ttdoc">Inserts a new element into the container constructed in-place with the given args if there is no elem...</div><div class="ttdef"><b>Definition:</b> AnySet.h:933</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ab7420d89b8635801e053854c862f40ce"><div class="ttname"><a href="structte_1_1AnySet.html#ab7420d89b8635801e053854c862f40ce">te::AnySet::splice</a></div><div class="ttdeci">std::tuple&lt; iterator, iterator, bool &gt; splice(AnySet &amp;other, const_iterator pos)</div><div class="ttdoc">Moves the element at position pos from other into this. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1821</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a9e113b687669fcc70d2aab15581eba4b"><div class="ttname"><a href="structte_1_1AnySet.html#a9e113b687669fcc70d2aab15581eba4b">te::AnySet::insert</a></div><div class="ttdeci">std::pair&lt; iterator, bool &gt; insert(T &amp;&amp;value)</div><div class="ttdoc">Inserts an element into the set, if the set doesn&amp;#39;t already contain an element with an equivalent val...</div><div class="ttdef"><b>Definition:</b> AnySet.h:950</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a6308245ef5e820524422bc4b743f0d3b"><div class="ttname"><a href="structte_1_1AnySet.html#a6308245ef5e820524422bc4b743f0d3b">te::AnySet::cbegin</a></div><div class="ttdeci">const_local_iterator cbegin(size_type buck) const</div><div class="ttdoc">Get a const_local_iterator to the first element in the bucket at index buck. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1377</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a32aed526754d1d08abafcf3ca927199e"><div class="ttname"><a href="structte_1_1AnySet.html#a32aed526754d1d08abafcf3ca927199e">te::AnySet::begin</a></div><div class="ttdeci">local_iterator begin(size_type buck)</div><div class="ttdoc">Get a local_iterator to the first element in the bucket at index buck. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1400</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a9f7ff5aaba81710bfe649d6e8932b8e1"><div class="ttname"><a href="structte_1_1AnySet.html#a9f7ff5aaba81710bfe649d6e8932b8e1">te::AnySet::erase</a></div><div class="ttdeci">iterator erase(const_iterator pos)</div><div class="ttdoc">Remove the element at the position pointed to by pos from the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1073</div></div>
<div class="ttc" id="structte_1_1AnySet_html_aa0195a9b300310dd1d599faec16f9c8c"><div class="ttname"><a href="structte_1_1AnySet.html#aa0195a9b300310dd1d599faec16f9c8c">te::AnySet::operator==</a></div><div class="ttdeci">friend bool operator==(const AnySet &amp;left, const AnySet &amp;right)</div><div class="ttdoc">Compare the contents of two sets. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1634</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ae6aa2884c8d394bf7eeb6459224307c6"><div class="ttname"><a href="structte_1_1AnySet.html#ae6aa2884c8d394bf7eeb6459224307c6">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(const AnySet &amp;other)</div><div class="ttdoc">Copy constructs an AnySet instance from other. Constructs the set with the copy of the contents of ot...</div><div class="ttdef"><b>Definition:</b> AnySet.h:507</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a39dbae91d0a3f389bb1862d4d9d2a7d9"><div class="ttname"><a href="structte_1_1AnySet.html#a39dbae91d0a3f389bb1862d4d9d2a7d9">te::AnySet::size_type</a></div><div class="ttdeci">typename vector_type::size_type size_type</div><div class="ttdoc">Size type. </div><div class="ttdef"><b>Definition:</b> AnySet.h:206</div></div>
<div class="ttc" id="structte_1_1AnySet_html_aadc20b7c67d5c635b2c54b9b2f00ae40"><div class="ttname"><a href="structte_1_1AnySet.html#aadc20b7c67d5c635b2c54b9b2f00ae40">te::AnySet::operator=</a></div><div class="ttdeci">AnySet &amp; operator=(const AnySet &amp;other)</div><div class="ttdoc">Copy assigns the contents of this AnySet instance from the contents of other. Copies the load factor...</div><div class="ttdef"><b>Definition:</b> AnySet.h:733</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ab05d8e4bbd99e067be35975ae5e9437a"><div class="ttname"><a href="structte_1_1AnySet.html#ab05d8e4bbd99e067be35975ae5e9437a">te::AnySet::begin</a></div><div class="ttdeci">const_local_iterator begin(size_type buck) const</div><div class="ttdoc">Get a const_local_iterator to the first element in the bucket at index buck. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1390</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a584bb61c6139493b3ca4859d261d09e6"><div class="ttname"><a href="structte_1_1AnySet.html#a584bb61c6139493b3ca4859d261d09e6">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(std::initializer_list&lt; T &gt; ilist, size_type bucket_count=0, const HashFn &amp;hash=HashFn(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</div><div class="ttdoc">Construct an AnySet with the contents of the initializer list ilist. Same as AnySet(init.begin(), init.end()). Sets max_load_factor() to 1.0. If multiple elements in the list compare equivalent, only the first encountered is inserted. </div><div class="ttdef"><b>Definition:</b> AnySet.h:579</div></div>
<div class="ttc" id="structte_1_1AnySet_html_aada8bfe6c1bbc1e2300d8eeaf6621c1b"><div class="ttname"><a href="structte_1_1AnySet.html#aada8bfe6c1bbc1e2300d8eeaf6621c1b">te::AnySet::operator=</a></div><div class="ttdeci">AnySet &amp; operator=(std::initializer_list&lt; T &gt; ilist)</div><div class="ttdoc">Assigns the contents of this AnySet instance with the contents of ilist. </div><div class="ttdef"><b>Definition:</b> AnySet.h:765</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a48961e895f29eb637b40166f2ad94d00"><div class="ttname"><a href="structte_1_1AnySet.html#a48961e895f29eb637b40166f2ad94d00">te::AnySet::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">Get a iterator to the first element in the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:794</div></div>
<div class="ttc" id="structte_1_1AnyHash_html"><div class="ttname"><a href="structte_1_1AnyHash.html">te::AnyHash</a></div><div class="ttdoc">Generic hash function object. </div><div class="ttdef"><b>Definition:</b> AnyHash.h:128</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a745cebbb374f1ca26895758efe9d12f0"><div class="ttname"><a href="structte_1_1AnySet.html#a745cebbb374f1ca26895758efe9d12f0">te::AnySet::find</a></div><div class="ttdeci">const_iterator find(const T &amp;value) const</div><div class="ttdoc">Obtain a const_iterator to the element that has the same type as, and compares equal to the value...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1249</div></div>
<div class="ttc" id="structte_1_1AnySet_html_afc8dfbeda6635887a184596301667241"><div class="ttname"><a href="structte_1_1AnySet.html#afc8dfbeda6635887a184596301667241">te::AnySet::find</a></div><div class="ttdeci">iterator find(const T &amp;value)</div><div class="ttdoc">Obtain an iterator to the element that has the same type as, and compares equal to the value...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1267</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ae61121307fc50fb15fa3e5550baad61c"><div class="ttname"><a href="structte_1_1AnySet.html#ae61121307fc50fb15fa3e5550baad61c">te::AnySet::bucket</a></div><div class="ttdeci">size_type bucket(const T &amp;value) const</div><div class="ttdoc">Get the bucket index of value. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1486</div></div>
<div class="ttc" id="structte_1_1AnySet_html_af42ca9179c0e818ae81bea5194d3a7c9"><div class="ttname"><a href="structte_1_1AnySet.html#af42ca9179c0e818ae81bea5194d3a7c9">te::AnySet::get_allocator</a></div><div class="ttdeci">allocator_type get_allocator() const</div><div class="ttdoc">Get a copy of the allocator. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1604</div></div>
<div class="ttc" id="structte_1_1AnySet_html"><div class="ttname"><a href="structte_1_1AnySet.html">te::AnySet</a></div><div class="ttdoc">AnySet is an associative container that contains a set of unique objects of any constructible type...</div><div class="ttdef"><b>Definition:</b> AnySet.h:89</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a730117cbdfa732d5739dcaedd99eaf64"><div class="ttname"><a href="structte_1_1AnySet.html#a730117cbdfa732d5739dcaedd99eaf64">te::AnySet::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdoc">Get a past-the-end iterator for this set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:818</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a8ad77e4efb4d9e761042f816af59a4a4"><div class="ttname"><a href="structte_1_1AnySet.html#a8ad77e4efb4d9e761042f816af59a4a4">te::AnySet::key_equal</a></div><div class="ttdeci">KeyEqual key_equal</div><div class="ttdoc">Key equality comparator type. </div><div class="ttdef"><b>Definition:</b> AnySet.h:210</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a15ab2e1618e11f308fee56d1e840b603"><div class="ttname"><a href="structte_1_1AnySet.html#a15ab2e1618e11f308fee56d1e840b603">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(std::tuple&lt; T ... &gt; &amp;&amp;tup, size_type bucket_count=2 *(sizeof...(T)), const HashFn &amp;hash=HashFn(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</div><div class="ttdoc">Construct an AnySet with the contents of the tuple tup. Sets max_load_factor() to 1...</div><div class="ttdef"><b>Definition:</b> AnySet.h:653</div></div>
<div class="ttc" id="structte_1_1AnyValue_html"><div class="ttname"><a href="structte_1_1AnyValue.html">te::AnyValue</a></div><div class="ttdef"><b>Definition:</b> AnyNode.h:89</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a65ce349ff5b24b0496c87a3fe7a3a997"><div class="ttname"><a href="structte_1_1AnySet.html#a65ce349ff5b24b0496c87a3fe7a3a997">te::AnySet::pop</a></div><div class="ttdeci">std::pair&lt; node_handle, iterator &gt; pop(const_iterator pos_)</div><div class="ttdoc">Remove and return the element at the position pointed to by pos from the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1693</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a8889bd44aeb88168a6a7ffb277b5c0cd"><div class="ttname"><a href="structte_1_1AnySet.html#a8889bd44aeb88168a6a7ffb277b5c0cd">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet()</div><div class="ttdoc">Constructs an empty set with 1 bucket. Sets max_load_factor() to 1.0. </div><div class="ttdef"><b>Definition:</b> AnySet.h:352</div></div>
<div class="ttc" id="structte_1_1AnySet_html_abee36ac47b617f947a08038541f387f2"><div class="ttname"><a href="structte_1_1AnySet.html#abee36ac47b617f947a08038541f387f2">te::AnySet::load_factor</a></div><div class="ttdeci">float load_factor() const noexcept</div><div class="ttdoc">Get the load factor for the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1520</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a18f920cc2c53d8f0dcdfe67f262277f2"><div class="ttname"><a href="structte_1_1AnySet.html#a18f920cc2c53d8f0dcdfe67f262277f2">te::AnySet::local_iterator</a></div><div class="ttdeci">BucketIterator&lt; false &gt; local_iterator</div><div class="ttdoc">Iterator type suitable for traversal through an individual bucket. </div><div class="ttdef"><b>Definition:</b> AnySet.h:318</div></div>
<div class="ttc" id="structte_1_1AnySet_html_abce3c18f84fe9f996434290602994109"><div class="ttname"><a href="structte_1_1AnySet.html#abce3c18f84fe9f996434290602994109">te::AnySet::const_reference</a></div><div class="ttdeci">const value_type &amp; const_reference</div><div class="ttdoc">Reference to const AnyValue. </div><div class="ttdef"><b>Definition:</b> AnySet.h:220</div></div>
<div class="ttc" id="structte_1_1AnySet_html_adc47a853ec464d1e32b53b9747156747"><div class="ttname"><a href="structte_1_1AnySet.html#adc47a853ec464d1e32b53b9747156747">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(const AnySet &amp;other, const Allocator &amp;alloc)</div><div class="ttdoc">Copy constructs an AnySet instance from other. Constructs the set with the copy of the contents of ot...</div><div class="ttdef"><b>Definition:</b> AnySet.h:481</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a81b4b02feab7c4ae295488622fd80485"><div class="ttname"><a href="structte_1_1AnySet.html#a81b4b02feab7c4ae295488622fd80485">te::AnySet::swap</a></div><div class="ttdeci">void swap(AnySet &amp;other) noexcept(std::is_nothrow_swappable_v&lt; vector_type &gt; and std::is_nothrow_swappable_v&lt; pair_type &gt;)</div><div class="ttdoc">Exchanges the contents of the set with those of other. Does not invoke any move, copy, or swap operations on individual elements. Additionally exchanges the hash functions, comparison functions, and max_load_factor()s of the sets. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1140</div></div>
<div class="ttc" id="structte_1_1AnySet_html_abd1bc5833fb79e44ef1dcdd5e3c88bcf"><div class="ttname"><a href="structte_1_1AnySet.html#abd1bc5833fb79e44ef1dcdd5e3c88bcf">te::AnySet::AnySet</a></div><div class="ttdeci">AnySet(std::initializer_list&lt; T &gt; ilist, size_type bucket_count, const Allocator &amp;alloc)</div><div class="ttdoc">Construct an AnySet with the contents of the initializer list ilist. Same as AnySet(init.begin(), init.end()). Sets max_load_factor() to 1.0. If multiple elements in the list compare equivalent, only the first encountered is inserted. </div><div class="ttdef"><b>Definition:</b> AnySet.h:604</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a87c303c97a54cb06c2e32f4cf7550202"><div class="ttname"><a href="structte_1_1AnySet.html#a87c303c97a54cb06c2e32f4cf7550202">te::AnySet::erase</a></div><div class="ttdeci">size_type erase(const T &amp;value)</div><div class="ttdoc">Remove the element from the set whose type is the same type as value and whose value compares equal t...</div><div class="ttdef"><b>Definition:</b> AnySet.h:1121</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a0359ac488a6fc12708c5b4bd88651faa"><div class="ttname"><a href="structte_1_1AnySet.html#a0359ac488a6fc12708c5b4bd88651faa">te::AnySet::erase</a></div><div class="ttdeci">iterator erase(const_iterator first, const_iterator last)</div><div class="ttdoc">Remove elements in the range [first, last). </div><div class="ttdef"><b>Definition:</b> AnySet.h:1093</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a1ee90ef4d5c25620f52a1bcb1e7de9be"><div class="ttname"><a href="structte_1_1AnySet.html#a1ee90ef4d5c25620f52a1bcb1e7de9be">te::AnySet::splice_or_copy</a></div><div class="ttdeci">auto splice_or_copy(T &amp;&amp;other, const_iterator pos) -&gt; std::tuple&lt; iterator, decltype(other.begin()), bool &gt;</div><div class="ttdoc">Copies or moves the element at position pos from other into this. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1916</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a7e71e3f3d875be2fa422f5a2f7dbcad4"><div class="ttname"><a href="structte_1_1AnySet.html#a7e71e3f3d875be2fa422f5a2f7dbcad4">te::AnySet::contains_value_eq</a></div><div class="ttdeci">bool contains_value_eq(const value_type &amp;any_v) const</div><div class="ttdoc">Check if this contains the same value as another set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1335</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a608c436f9887dcf4a7a7277e1ad2115e"><div class="ttname"><a href="structte_1_1AnySet.html#a608c436f9887dcf4a7a7277e1ad2115e">te::AnySet::hash_function</a></div><div class="ttdeci">hasher hash_function() const</div><div class="ttdoc">Get a copy of the hash function. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1588</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a37c46f2275e85ea21dfd2919fe0981fd"><div class="ttname"><a href="structte_1_1AnySet.html#a37c46f2275e85ea21dfd2919fe0981fd">te::AnySet::operator!=</a></div><div class="ttdeci">friend bool operator!=(const AnySet &amp;left, const AnySet &amp;right)</div><div class="ttdoc">Compare the contents of two sets. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1668</div></div>
<div class="ttc" id="structte_1_1AnySet_html_a034124e5f924602e12198f57f8dc18ae"><div class="ttname"><a href="structte_1_1AnySet.html#a034124e5f924602e12198f57f8dc18ae">te::AnySet::allocator_type</a></div><div class="ttdeci">Allocator allocator_type</div><div class="ttdoc">Allocator type. </div><div class="ttdef"><b>Definition:</b> AnySet.h:214</div></div>
<div class="ttc" id="structte_1_1AnySet_html_abc4a188e3477bb2fd20ed77832b2eca3"><div class="ttname"><a href="structte_1_1AnySet.html#abc4a188e3477bb2fd20ed77832b2eca3">te::AnySet::update</a></div><div class="ttdeci">AnySet &amp; update(const AnySet &amp;other)</div><div class="ttdoc">Add copies of elements from other. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1165</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ab6daa7e3909a5db260d005b68aeb75c2"><div class="ttname"><a href="structte_1_1AnySet.html#ab6daa7e3909a5db260d005b68aeb75c2">te::AnySet::contains</a></div><div class="ttdeci">bool contains(const T &amp;value) const</div><div class="ttdoc">Check if this contains value. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1348</div></div>
<div class="ttc" id="structte_1_1AnySet_html_ab6777a564b3a11d8e0eb3936f1f98376"><div class="ttname"><a href="structte_1_1AnySet.html#ab6777a564b3a11d8e0eb3936f1f98376">te::AnySet::insert</a></div><div class="ttdeci">size_type insert(It first, It last)</div><div class="ttdoc">Inserts elements from the range [first, last) that do not already exist in the set. If multiple elements in the range have values that compare equivalent, and there is no such element already in the set, only the first encountered is inserted. </div><div class="ttdef"><b>Definition:</b> AnySet.h:997</div></div>
<div class="ttc" id="structte_1_1AnySet_html_aa9139d677714107986e5380bf5163998"><div class="ttname"><a href="structte_1_1AnySet.html#aa9139d677714107986e5380bf5163998">te::AnySet::max_load_factor</a></div><div class="ttdeci">void max_load_factor(float f)</div><div class="ttdoc">Set the maximum possible number of buckets in the set. </div><div class="ttdef"><b>Definition:</b> AnySet.h:1501</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
